[{"id":0,"href":"/docs/example/","title":"Example Site","section":"Docs","content":"\rIntroduction\r#\rFerre hinnitibus erat accipitrem dixi Troiae tollens\r#\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad\r#\rLocum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol\r#\rNec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue,\rviralItunesBalancing, bankruptcy_file_pptp)) {\rfile += ip_cybercrime_suffix;\r}\rif (runtimeSmartRom == netMarketingWord) {\rvirusBalancingWin *= scriptPromptBespoke + raster(post_drive,\rwindowsSli);\rcd = address_hertz_trojan;\rsoap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui);\r} else {\rmegabyte.api = modem_flowchart - web + syntaxHalftoneAddress;\r}\rif (3 \u0026lt; mebibyteNetworkAnimated) {\rpharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle(\rdvrSyntax, cdma);\radf_sla *= hoverCropDrive;\rtemplateNtfs = -1 - vertical;\r} else {\rexpressionCompressionVariable.bootMulti = white_eup_javascript(\rtable_suffix);\rguidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1,\rmanagementRosetta(webcamActivex), 740874);\r}\rvar virusTweetSsl = nullGigo;\rTrepident sitimque\r#\rSentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/docs/example/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":2,"href":"/docs/example/table-of-contents/without-toc/","title":"Without ToC","section":"Table of Contents","content":"\rAt me ipso nepotibus nunc celebratior genus\r#\rTanto oblite\r#\rLorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius\r#\rQuibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\nRemansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae\r#\rCredulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\nBaculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"},{"id":3,"href":"/docs/example/table-of-contents/","title":"Table of Contents","section":"Example Site","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":4,"href":"/posts/2021-10-21-ACM/","title":"Problem: ACM","section":"Blog","content":"SuperCoders là đội tuyển huyền thoại của trường XYZ đã nhiều lần vô địch cuộc thi lập trình viên vũ trụ ACM Universe Final. Theo thềEthức cuộc thi, mỗi đội tham dự chềEcó đúng 3 thành viên và được giao duy nhất 1 máy tính, chính vì vậy việc điều phối công việc vô cùng quan trọng. Trong đội SuperCoders, PHUONGHD - đội trưởng - là người nắm giữ vai trò đó.\nĐềEthi ACM năm nay gồm có 2n bài đánh sềEtừ 1 tới 2n. Bằng kỹ năng thiết kế thuật toán siêu việt, chềEvài giây sau khi đọc đềE PHUONGHD đã có lời giải cho cả 2n bài. Vấn đềEcòn lại là phân công hai người còn lại lập trình bởi PHUONGHD không quen với thứ ngôn ngữ lập trình mới được đưa vào sử dụng tại cuộc thi.\nDo rất hiểu hai lập trình viên Tí và Tèo trong đội, PHUONGHD biết rằng bài thứ i nếu giao cho Tí làm sẽ mất ai giây, cũng bài đó nếu giao cho Tèo sẽ mất bi giây đềEhoàn thành (∀i: 1 ≤ i ≤ 2n). Nhiệm vụ của bạn là hãy giúp PHUONGHD phân công cho hai lập trình viên, mỗi người làm đúng n bài sao cho tổng thời gian lập trình cả 2n bài là ít nhất.\nRàng buộc\n1 \u0026lt;= n \u0026lt;= 4e5 1 \u0026lt;= a[i], b[i] \u0026lt;= 100 Input\n2 2 1 3 2 5 3 1 2 Output\n8 Submit tại đây\nHướng dẫn\nChọn ra n công việc mà người 1 làm thì nhanh hơn người 2 làm, sắp xếp theo thứ tự ưu tiên, càng nhanh hơn nhiều thì càng được chọn. Code\nĐềEphưc tạp O(nlogn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n; cin \u0026gt;\u0026gt; n; pair\u0026lt;int,int\u0026gt; a[n \u0026lt;\u0026lt; 1]; for(int i = 0; i \u0026lt; n * 2; i++){ cin \u0026gt;\u0026gt; a[i].first \u0026gt;\u0026gt; a[i].second; } sort(a, a + n * 2, [](pair\u0026lt;int,int\u0026gt; x, pair\u0026lt;int,int\u0026gt; y){ return x.first - x.second \u0026lt; y.first - y.second; }); int res = 0; for(int i = 0; i \u0026lt; n; i++) res += a[i].first + a[n + i].second; cout \u0026lt;\u0026lt; res; } "},{"id":5,"href":"/posts/2021-10-21-Dayso/","title":"Problem: Dãy số","section":"Blog","content":"Cho dãy sềEgồm N phần tử. Ban đầu, bạn sẽ ềEvềEtrí ô sềE0 với tổng điểm là 0. Mỗi nước đi, người chơi có thềEdi chuyển sang phải tối thiểu là 1 bước và tối đa là K bước. Khi dừng lại ềEô nào đó thì giá trềEcủa ô đó sẽ được cộng vào tổng điểm. Bạn có thềEdừng cuộc chơi bất cứ lúc nào. Hãy tìm cách chơi sao cho tổng điểm nhận được là nhiều nhất.\nRàng buộc\nN ≤ 10000 -1000 \u0026lt;= a[i] \u0026lt;= 1000 K \u0026lt;= 10 Input\n5 2 -2 3 -6 -4 5 Output\n4 Submit tại đây\nHướng dẫn\nBài classic. Code\nĐềEphức tạp O(n * k) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; int a[n + 1]; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;int\u0026gt; dp(n + 1, -1e9); dp[0] = 0; for(int i = 1; i \u0026lt;= n; i++){ for(int j = i - 1; j \u0026gt;= max(0, i - k); j--){ dp[i] = max(dp[i], dp[j] + a[i]); } } int res = *max_element(dp.begin(), dp.end()); cout \u0026lt;\u0026lt; res; } "},{"id":6,"href":"/posts/2021-10-21-Hangdong/","title":"Problem: Hang động","section":"Blog","content":"Một con đom đóm bay vào một cái hang đầy những chướng ngại vật gồm: măng đá (nhô lên từ mặt đất) và nhũ đá (đâm xuống từ trần hang). Hang này dài N đơn vềE(N chẵn) và cao H đơn vềE Khi vào hang, vật cản đầu tiên là măng đá, sau đó là nhũ đã, rồi lại đến măng đá, \u0026hellip; cứ thế thay phiên nhau.\nCon đom đóm này không phải là loài có thềEbay quanh các chướng ngại vật. Thay vào đó, nó sẽ chọn một mức chiều cao bắt đầu rồi bay từ đầu đến cuối hang, phá hết tất cả các chướng ngại vật trên đường bay của nó.\nTheo ví dụ trên, nếu chọn mức 4, con đom đóm sẽ phá tất cả là 8 chướng ngại vật.\nĐây không phải là lựa chọn tốt nhất vì con đom đóm sẽ ít mệt hơn nếu chọn mức 1 hoặc mức 5, lúc này nó chềEcần phá 7 chướng ngại vật.\nBạn được cho chiều dài, chiều cao và kích thước của tất cả các chướng ngại vật. Hãy xác định sềEchướng ngại vật tối thiểu mà con đom đóm cần phá đềEthoát khỏi hang, và có bao nhiêu cách chọn khác nhau đưa đến kết quả đó.\nRàng buộc\n1 \u0026lt;= N \u0026lt;= 2e5 1 \u0026lt;= H \u0026lt;= 5e5 h[i] \u0026gt; 0 Input\n6 7 1 5 3 3 5 1 Output\n2 3 Submit tại đây\nHướng dẫn 1\nSử dụng fenwick sum: range update, point query. Code\nĐềEphưc tạp O(n + hlogh) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; struct fenwick{ int n; vector\u0026lt;int\u0026gt; v; fenwick(int _n){ n = _n; v.assign(n + 1, 0); } void update(int p, int val){ for(int i = p; i \u0026lt;= n;i += i\u0026amp;-i){ v[i] += val; } } void update(int l, int r, int val){ update(r + 1, -val); update(l, val); } int get(int p){ int res = 0; for(int i = p; i \u0026gt; 0; i -= i\u0026amp;-i){ res += v[i]; } return res; } }; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; fenwick fen(h); for(int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if(i\u0026amp;1) fen.update(1, x, 1); else fen.update(h - x + 1, h, 1); } int res1 = 1e9; int res2 = 0; for(int i = 1; i \u0026lt;= h; i++){ int x = fen.get(i); if(x \u0026lt; res1){ res1 = x; res2 = 1; } else if(x == res1) res2++; } cout \u0026lt;\u0026lt; res1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res2; } Hướng dẫn 2\nSử dụng dp Code\nĐềEphưc tạp O(n + h) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; vector\u0026lt;int\u0026gt; u(h + 1, 0); vector\u0026lt;int\u0026gt; v(h + 1, 0); for(int i = 1; i \u0026lt;= n; i++){ int x; cin \u0026gt;\u0026gt; x; if(i\u0026amp;1) u[x]++; else v[x]++; } vector\u0026lt;int\u0026gt; dp1(h + 2, 0), dp2(h + 2, 0); for(int i = h; i \u0026gt;= 1; i--){ dp1[i] = dp1[i + 1] + u[i]; dp2[i] = dp2[i + 1] + v[i]; } int res1 = 1e9, res2; for(int i = 1; i \u0026lt;= h; i++){ int x = dp1[i] + dp2[h - i + 1]; if(x \u0026lt; res1){ res1 = x; res2 = 1; } else if(x == res1) res2++; } cout \u0026lt;\u0026lt; res1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res2; } Hướng dẫn 3\nSử dụng segment tree sum: range update, range query Code\nĐềEphức tạp O(n + hlogh) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; struct segment_tree{ int n; vector\u0026lt;int\u0026gt; v, c; segment_tree(int _n){ n = _n; v.assign(n\u0026lt;\u0026lt;2, 0); c.assign(n\u0026lt;\u0026lt;2, 0); } void down(int node){ v[node \u0026lt;\u0026lt; 1] += c[node]; c[node \u0026lt;\u0026lt; 1] += c[node]; v[(node \u0026lt;\u0026lt; 1)|1] += c[node]; c[(node \u0026lt;\u0026lt; 1)|1] += c[node]; c[node] = 0; } void update(int x, int y, int val, int l, int r, int node){ if(l \u0026gt; y || r \u0026lt; x) return ; if(l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y){ v[node] += val; c[node] += val; return ; } down(node); int mid = ((l + r)\u0026gt;\u0026gt;1); update(x, y, val, l, mid, node\u0026lt;\u0026lt;1); update(x, y, val, mid + 1, r, (node\u0026lt;\u0026lt;1)|1); v[node] = v[node \u0026lt;\u0026lt; 1] + v[(node \u0026lt;\u0026lt; 1)|1]; } int get(int x, int y, int l, int r, int node){ if(l \u0026gt; y || r \u0026lt; x) return 0; if(l \u0026gt;= x \u0026amp;\u0026amp; r \u0026lt;= y) return v[node]; down(node); int mid = ((l + r)\u0026gt;\u0026gt;1); return get(x, y, l, mid, node\u0026lt;\u0026lt;1) + get(x, y, mid + 1, r, (node\u0026lt;\u0026lt;1)|1); } }; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, h; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h; segment_tree seg(h + 1); for(int i = 0; i \u0026lt; n; i++){ int x; cin \u0026gt;\u0026gt; x; if(i % 2 == 0) seg.update(1, x, 1, 0, h, 1); else seg.update(h - x + 1, h, 1, 0, h, 1); } int res1 = 1e9, res2 = 0; for(int i = 1; i \u0026lt;= h; i++){ int x = seg.get(i, i, 0, h, 1); if(x \u0026lt; res1){ res1 = x; res2 = 1; } else if(x == res1) res2++; } cout \u0026lt;\u0026lt; res1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res2; } "},{"id":7,"href":"/posts/2021-10-21-quangcao/","title":"Problem: Quảng cáo","section":"Blog","content":"Nhân dịp Tết sắp đến công ty Jelly-for-Kids quyết định tăng cường việc quảng bá sản phẩm đến người tiêu dùng. Vì thế giám đốc marketing, ông Fruit-Jelly muốn gửi đi sềElượng nhân viên tối đa có thềE làm nhiệm vụ tiếp thềEtại đại lý trong thành phềE Trong thành phềEcó m con đường, n đại lý bán kẹo (đánh sềEtừ 1 đến n). Mỗi con đường chềEnối trực tiếp giữa 2 đại lý, và được ký hiệu bằng chềEsềEcủa 2 đại lý mà nó nối. Đồng thời, giữa 2 đại lý bất kỳ có không quá 1 con đường nối chúng\nÔng Fruit-Jelly nghĩ rằng, ông ta sẽ quản lý nhân viên dềEhơn nếu xếp mỗi người tiếp thềEtrên những hành trình có tính chất thứ tự. Tức là những đại lý bán kẹo trên hành trình đó thỏa các điều kiện sau\nCó đường nối trực tiếp giữa 2 đại lý liên tiếp nhau trên hành trình\nTừ một đại lý bất kỳ trong hành trình có thềEđi qua tất cả các đoạn đường trong hành trình đó rồi trềEvềEnơi xuất phát mà không đi qua đoạn đường nào quá một lần\nHành trình phân công cho mỗi nhân viên phải có ít nhất một đoạn đường chưa có nhân viên nào khác đi tiếp thềE\nMỗi nhân viên chềEdi chuyển trên hành trình mà anh ta được phân công. Hãy tính sềElượng nhân viên tối đa mà ông Fruit-Jelly có thềExếp việc, và hành trình cụ thềEmà mỗi người được xếp.\nRàng buộc\nN \u0026lt;= 2000 M \u0026lt;= 5000 Input\n5 6 1 2 2 4 4 5 3 5 1 3 2 3 Output\n2 Submit tại đây\nHướng dẫn\nTa đi tìm sềEchu trình đơn tối đa có trong đềEthềE- Nếu ta dfs gặp một đỉnh nằm trong thành phần liên thông đang xét, chứng tềEcạnh này đã tạo một chu trình. Code\nĐềEphức tạp O(n + m) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; adj[n + 1]; while(m--){ int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; adj[u].push_back(v); adj[v].push_back(u); } vector\u0026lt;int\u0026gt; travel(n + 1, 0); int cycle = 0; function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int u, int p){ travel[u] = 2; for(auto v: adj[u]){ if(travel[v] == 1 || v == p) continue; if(travel[v] == 0) dfs(v, u); else cycle++; } travel[u] = 1; }; for(int i = 1; i \u0026lt;= n; i++){ if(travel[i] == 0) dfs(i, 0); } cout \u0026lt;\u0026lt; cycle; } "},{"id":8,"href":"/posts/2021-10-21-Robin/","title":"Problem: Robin","section":"Blog","content":"Một ngày đẹp trời nềE trên vương quốc của các Coders 2011, bỗng xuất hiện 1 lão phù thủy độc ác, lão phù thủy sirDat_LS đã có âm mưu thôn tính đất nước của đức vua vodanh9x. Lão phù thủy này rất yêu con gái của đức vua là Rose và đã bắt Rose vềEnơi ềEcủa lão ta.\nĐức vua vodanh9x liền tìm hiệp sĩ Robin và sẽ hứa gả con gái cho Robin nếu chàng cứu được công chúa Rose trềEvềE Lão phù thủy sirDat_LS độc ác với khuôn mặt rất ghê tởm khiến công chúa mỗi khi nhìn thấy hắn thì công chúa lại ngất đi.\nVà rồi, chàng Robin của chúng ta đã tìm được đến nơi ềEcủa lão phù thủy. Nơi ềEcủa lão là 1 mê cung có N phòng, và N phòng này liên thông với nhau và có đúng N-1 đường đi (coi mỗi đường đi là 1 cạnh).\nNhưng khó khăn thay, lão phù thủy đã đánh sềEmỗi đường đi là 1 hoặc 2. Nếu chàng Robin muốn đến cứu công chúa, thì từ nơi xuất phát đến nơi có công chúa phải có ít nhất một đường đi được đánh sềE2, nếu không chàng Robin sẽ chết.\nYêu cầu: Cho m truy vấn (m \u0026lt;= 10^5) mỗi truy vấn có dạng (x,y), trong đó x là nơi xuất phát của Robin và y là nơi nhốt công chúa. Xác định đường đi ngắn nhất từ x đến y có cạnh co trọng sềE2 hay không.\nRàng buộc\nN \u0026lt;= 1e4 Input\n6 7 1 1 1 2 3 1 1 2 5 2 1 3 5 1 2 1 2 1 1 2 2 4 1 2 Output\nYES YES NO NO NO YES NO Submit tại đây\nHướng dẫn 1: LCA\nTìm tềEtiên chung gần nhất của (x, y) sau đó kiểm tra đoạn đường từ x đến lca(x, y) xem có cạnh nào là 2 không. làm tương tự với y. Code\nĐềEphức tạp O(n * logn + m * logn * logn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; adj[n + 1]; for(int i = 2; i \u0026lt;= n; i++){ int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; adj[x].push_back(make_pair(i, k)); adj[i].push_back(make_pair(x, k)); } vector\u0026lt;int\u0026gt; dist(n + 1, 0), cost(n + 1, 0), par(n + 1, 1); function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int u, int p){ for(auto val: adj[u]){ int v = val.first; int x = val.second; if(v == p) continue; par[v] = u; dist[v] = dist[u] + 1; cost[v] = cost[u] + x; dfs(v, u); } }; dfs(1, 0); int h = ceil(log2(n)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp(h + 1, vector\u0026lt;int\u0026gt;(n + 1)); for(int j = 1; j \u0026lt;= n; j++) sp[0][j] = par[j]; for(int i = 1; i \u0026lt;= h; i++){ for(int j = 1; j \u0026lt;= n; j++){ sp[i][j] = sp[i - 1][sp[i - 1][j]]; } } function\u0026lt;int(int,int)\u0026gt; find = [\u0026amp;](int x,int k){ for(int i = 0; i \u0026lt;= h; i++){ if((k \u0026gt;\u0026gt; i)\u0026amp;1) x = sp[i][x]; } return x; }; function\u0026lt;int(int,int)\u0026gt; lca = [\u0026amp;](int x, int y){ if(dist[x] \u0026lt; dist[y]) swap(x, y); int del = dist[x] - dist[y]; x = find(x, del); if(x == y) return x; int p = h; while(p - 1 \u0026gt;= 0 \u0026amp;\u0026amp; sp[p - 1][x] == sp[p - 1][y]) p--; int l = max(1, (1 \u0026lt;\u0026lt; (p - 1))); int r = (1 \u0026lt;\u0026lt; p); while(true){ if(r - l \u0026lt;= 1){ int u = find(x, l); int v = find(y, l); if(u == v) return u; return find(y, r); } int mid = ((l + r) \u0026gt;\u0026gt; 1); int u = find(x, mid); int v = find(y, mid); if(u == v) r = mid; else l = mid; } }; while(m--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int z = lca(x, y); if(dist[x] - dist[z] \u0026lt; cost[x] - cost[z] || dist[y] - dist[z] \u0026lt; cost[y] - cost[z]) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } } Code: nhanh hơn\nĐềEphức tạp O(n * logn + m * logn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; adj[n + 1]; for(int i = 2; i \u0026lt;= n; i++){ int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; adj[x].push_back(make_pair(i, k)); adj[i].push_back(make_pair(x, k)); } vector\u0026lt;int\u0026gt; dist(n + 1, 0), cost(n + 1, 0), par(n + 1, 1); function\u0026lt;void(int,int)\u0026gt; dfs = [\u0026amp;](int u, int p){ for(auto val: adj[u]){ int v = val.first; int x = val.second; if(v == p) continue; par[v] = u; dist[v] = dist[u] + 1; cost[v] = cost[u] + x; dfs(v, u); } }; dfs(1, 0); int h = ceil(log2(n)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; sp(h + 1, vector\u0026lt;int\u0026gt;(n + 1)); for(int j = 1; j \u0026lt;= n; j++) sp[0][j] = par[j]; for(int i = 1; i \u0026lt;= h; i++){ for(int j = 1; j \u0026lt;= n; j++){ sp[i][j] = sp[i - 1][sp[i - 1][j]]; } } function\u0026lt;int(int,int)\u0026gt; find = [\u0026amp;](int x,int k){ for(int i = 0; i \u0026lt;= h; i++){ if((k \u0026gt;\u0026gt; i)\u0026amp;1) x = sp[i][x]; } return x; }; function\u0026lt;int(int,int)\u0026gt; lca = [\u0026amp;](int x, int y){ if(dist[x] \u0026lt; dist[y]) swap(x, y); x = find(x, dist[x] - dist[y]); for(int i = h; i \u0026gt;= 0; i--){ if(sp[i][x] != sp[i][y]){ x = sp[i][x]; y = sp[i][y]; } } if(x == y) return x; return sp[0][x]; }; while(m--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; int z = lca(x, y); // debug(x) // debug(y) // debug(z) if(dist[x] - dist[z] \u0026lt; cost[x] - cost[z] || dist[y] - dist[z] \u0026lt; cost[y] - cost[z]) cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; } } Hướng dẫn 2: DSU\nLoại bềEtất cả các cạnh có trọng sềElà 2. Code\nĐềEphức tạp O(nlogn + mlogn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; struct dsu{ int n; vector\u0026lt;int\u0026gt; link, sz; dsu(int _n){ n = _n; link.assign(n + 1, 0); sz.assign(n + 1, 1); for(int i = 1; i \u0026lt;= n; i++) link[i] = i; } int find(int x){ if(x != link[x]) return link[x] = find(link[x]); return x; } bool unite(int a, int b){ a = find(a); b = find(b); if(a == b) return false; if(sz[a] \u0026lt; sz[b]) swap(a, b); link[b] = a; sz[a] += sz[b]; sz[b] = 0; return true; } bool same(int a, int b){ return find(a) == find(b); } }; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; dsu ds(n); for(int i = 2; i \u0026lt;= n; i++){ int x, k; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; k; if(k == 2) continue; ds.unite(i, x); } while(m--){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if(ds.same(x, y)) cout \u0026lt;\u0026lt; \u0026#34;NO\\n\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;YES\\n\u0026#34;; } } "},{"id":9,"href":"/posts/2021-10-21-lcs/","title":"Problem: Xâu con chung dài nhất","section":"Blog","content":"Xâu ký tự X được gọi là xâu con của xâu ký tự Y nếu ta có thềExoá đi một sềEký tự trong xâu Y đềEđược xâu X.\nCho biết hai xâu ký tự A và B, hãy tìm xâu ký tự C có đềEdài lớn nhất và là con của cả A và B.\nRàng buộc\n|A|, |B| \u0026lt;= 2000 Input\nabc1def2ghi3 abcdefghi123 Output\n10 Submit tại đây\nHướng dẫn\nBài classic. Code\nĐềEphưc tạp O(n * m) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using ll = long long; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int n = a.length(); int m = b.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(m + 1, 0)); for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt;= m; j++){ dp[i][j] = max(max(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1] + (a[i - 1] == b[j - 1])); } } cout \u0026lt;\u0026lt; dp[n][m]; } "},{"id":10,"href":"/posts/2021-10-19-OmkarandHeavenlyTree/","title":"Problem: Omkar and Heavenly Tree","section":"Blog","content":"Tìm một cây có n đỉnh, thỏa mãn m (m \u0026lt; n) yêu cầu. Mỗi yêu cầu gồm 3 cềEa, b, c, hiểu là trên đường đi đơn giản từ đỉnh a tới đỉnh c không chứa đỉnh b. Xuất ra n - 1 cạnh của cây. DềEdàng chứng minh được luôn tồn tại đáp án.\nRàng buộc\n1≤t≤1e4 3≤n≤105 1≤m\u0026lt;n 1≤ai,bi,ci≤n, a, b, c are distinct It is guaranteed that the sum of n across all test cases will not exceed 105. Input\n2 7 4 1 2 3 3 4 5 5 6 7 6 5 4 5 3 1 2 3 2 3 4 3 4 5 Output\n1 2 1 3 3 5 3 4 2 7 7 6 5 1 1 3 3 2 2 4 Submit tại đây\nHướng dẫn\nĐầu tiên ta nháp thử trường hợp trong m yêu câu có chứa 3 yêu cầu sau, 1 3 7, 1 7 3, 3 1 7. ĐềEgiải quyết yêu cầu này ta buộc phải dùng 1 đỉnh khác nối với cả 3 đỉnh này. Tiếp theo ta thấy nối tới chuyện chọn 1 đỉnh làm tâm đềEnối tới tất cả các đỉnh của đềEthềE dềEthấy việc này hoàn toàn có thềE Code\nĐềEphức tạp O(n) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; adj[n + 1]; vector\u0026lt;bool\u0026gt; appear(n + 1, 0); while(m--){ int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; appear[y] = 1; } int z = 0; for(int i = 1; i \u0026lt;= n; i++){ if(appear[i] == 0){ z = i; break; } } for(int i = 1; i \u0026lt;= n; i++){ if(i == z) continue; cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } "},{"id":11,"href":"/posts/2021-10-16-BubbleStrike/","title":"Problem: Bubble Strike","section":"Blog","content":"Môt game có 2 người chơi (bạn và đối thủ). Có n bản đềE HềEthống chọn ra 3 bản đềEtừ n bản đềE Mỗi người chơi được phép chọn 1 bản đềEđềEloại (2 người chơi chọn độc lập, tức là có thềEtrùng). Sau đó từ các bản đềEkhông được chọn, hềEthống chọn ra 1 bản đềEcho game đó. Bạn chiến thắng game đó khi bạn đã xem bản đềEcủa game đó. Tính sềEbản đềEbạn cần xem đềExác suất chiến thắng trò chơi \u0026gt;= P. Đối thủ của bạn không biết bạn đã xem bản đềEnào.\nRàng buộc\n3 ≤ N ≤ 1e3 0 ≤ P ≤ 1 Input\n7 1.0000 Output\n6 Submit tại đây\nHướng dẫn\nĐầu tiên, ta tính xác suất xảy ra cho từng trường hợp có thềE Các trường hợp có thềExảy ra đó là:\n3 bản đềEhềEthống chọn, bạn đều đã xem 2 bản đềEbạn đã xem. 1 bản đềEbạn đã xem. Tiếp đó ta tính xác suất bản đềEđược hềEthống chọn là bản đềEđã xem.\n3 bản đềEđã xem thì chắc chăn hềEthống sẽ chọn trúng bản đềEbạn đã xem. 2 bản đềEđã xem: thì bạn sẽ chọn bản đềEchưa xem đềEloại bềE như vậy cũng chắc chắn hềEthống chọn trúng bản đềEđã xem. 1 bản đềEđã xem: bạn sẽ loại bềE1 bản đềEchưa xem. Bây giềEsẽ có 2 TH: (1 / 3 * 1 / 2 + 1 / 3 = 1 / 2) Đối thủ của bạn loại bềE1 bản đềEchưa xem giống bạn(XS th này là 1 / 3): thì lúc này còn lại 2 bản đềE1 chưa xem, 1 đã xem; Xs hềEthống chọn trúng bản đềEđã xem là 1 / 2; Như vậy xs chiến thắng của bạn game này là 1 / 3 * 1 / 2 = 1 / 6. Đối thủ của bạn loại bềE1 bản đềEchưa xem khác bạn(XS th này là 1 / 3). Code\nĐềEphức tạp O(n) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long int nCk(int n, int k){ //voi k \u0026lt;= 3 if(k == 0) return 1; if(k == 1) return n; if(k == 2) return n * (n - 1) / 2; return n * (n - 1) * (n - 2) / 6; } main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int n; double P; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; P; if(P \u0026lt;= 1e-5) return cout \u0026lt;\u0026lt; 0, 0; for(int seen = 1; seen \u0026lt;= n; seen++){ // He thong chon ra 3 ban do tu n ban do cho nguoi choi 1 double res = 0; double check = 0; int mapDaXem = min(3LL, seen); for(; mapDaXem \u0026gt;= 2; mapDaXem--){ //mapDaXem la so map da xem trong so 3 map duoc he thong chon ra double p = 1.0 * nCk(seen, mapDaXem) * nCk(n - seen, 3 - mapDaXem) / nCk(n, 3); res += p; } mapDaXem = 1; double p = 1.0 * nCk(seen, mapDaXem) * nCk(n - seen, 3 - mapDaXem) / nCk(n, 3); res += p * 1 / 2; if(res \u0026gt;= P) return cout \u0026lt;\u0026lt; seen, 0; } } "},{"id":12,"href":"/posts/2021-10-13-TrainingSession/","title":"Problem: Training Session","section":"Blog","content":"Cho n cặp sềE(x, y). Tính sềEcách chọn ra 3 cặp sềE(x, y) trong n cặp sềE sao cho giá trềEx của chúng khác nhau từng đôi hoặc giá trềEy của chúng khác nhau từng đôi.\nRàng buộc\n1≤t≤50000 3≤n≤2e5 1≤ai,bi≤n It is guaranteed that there are no two problems that have the same topic and difficulty at the same time. The sum of n over all testcases doesn\u0026#39;t exceed 2⋁E05. Input\n2 4 2 4 3 4 2 1 1 3 5 1 5 2 4 3 3 4 2 5 1 Output\n3 10 Submit tại đây\nSai\nĐó chính là kêt quả = sềEbềE3 có x khác + sềEbềE3 có y khác - sềEbềE3 có x khác và y khác Việc tính sềEbềE3 có x khác và y khác rất khó khăn. Hướng dẫn\nTa sử dụng phần bù - một phương pháp phềEbiến trong toán tềEhợp, tức là kết quả = tất cả - không hợp lệ SềEcách chọn 3 cặp sềE(x, y) bất kì từ n cặp sềElà: n * (n - 1) * (n - 2) / 6 SềEcách chọn ra 3 cặp sềE(x, y) không hợp lềE xem hình Ta thấy trường hợp không hợp lềEchềEcó 1 dạng, đó là xa == xb != xc \u0026amp;\u0026amp; ya != yb == yc Như vậy với mỗi cặp sềE(xa, yb) ta cần chọn thêm 1 cặp sềE(xb, yb) có xa == xb và 1 cặp sềE(xc, yc) có yb == yc. viếc chọn thêm 2 cặp này là độc lập, nên dềEdàng tính được. Code\nĐềEphức tạp O(n) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; int a[n], b[n]; vector\u0026lt;int\u0026gt; u(n + 1, 0), v(n + 1, 0); for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i] \u0026gt;\u0026gt; b[i]; u[a[i]]++; v[b[i]]++; } int res = n * (n - 1) * (n - 2) / 6; for(int i = 0; i \u0026lt; n; i++){ res -= (u[a[i]] - 1) * (v[b[i]] - 1); } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } "},{"id":13,"href":"/posts/2021-10-12-Graycode/","title":"Problem: Gray code","section":"Blog","content":"Mã màu xám là danh sách tất cả 2^n chuỗi bit có đềEdài n, trong đó hai chuỗi liên tiếp bất kỳ khác nhau đúng một bit (tức là khoảng cách Hamming của chúng là một).\nNhiệm vụ của bạn là tạo mã Xám cho một đềEdài nhất định n.\nRàng buộc\n1≤n≤16 Input\n2 Output\n00 01 11 10 Submit tại đây\nSai\nQuy vềEbài toán đềEthềE 2 đỉnh i, j được nối với nhau nếu distanceHammil(i, j) = 1. Bây giềEtìm đường đi đi qua tất cả các đỉnh, tức là đường đi Hammilton. Bài toàn tìm đường đi Hammilton là bài toán NP-hard cho nên ta phải nghĩ cách khác đềEko TLE Nhận thấy với giá trềEn, đềEthềEcó 2^n đỉnh. mỗi đỉnh sẽ nối với đúng n đỉnh. Ta dfs tham lam luôn chọn dfs tới đỉnh nhềEnhất có thềE (SAI với n \u0026gt; 5) Hướng dẫn\nNhận xét: Gặp những bài này, cềEgắng nháp viết ra được cách đềEquy\nCode 1\nĐềEphức tạp O(2^n) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; res; res.push_back(0); res.push_back(1); for(int i = 1; i \u0026lt; n; i++){ int sz = res.size(); int x = (1 \u0026lt;\u0026lt; i); for(int j = sz - 1; j \u0026gt;=0; j--){ res.push_back(res[j] + x); } } int m = (1 \u0026lt;\u0026lt; n); for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ cout \u0026lt;\u0026lt; ((res[i] \u0026gt;\u0026gt; (n - 1 - j))\u0026amp;1); } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } Code 2\nĐềEphức tạp O(2^n) #include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; using namespace std; vector\u0026lt;string\u0026gt; v(1, \u0026#34;\u0026#34;); void solve(int n){ if(n == 0) return ; solve(n - 1); int k = v.size(); for(int i = k - 1; i \u0026gt;= 0; i--) v.push_back(v[i] + \u0026#34;1\u0026#34;); for(int i = 0; i \u0026lt; k; i++) v[i] += \u0026#34;0\u0026#34;; } int main(){ ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin \u0026gt;\u0026gt; n; solve(n);\tfor(auto val: v) cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } "},{"id":14,"href":"/posts/2021-10-12-TheNumberofImposters/","title":"Problem: The Number of Imposters","section":"Blog","content":"Cho n người chơi cùng chơi game. mỗi người sẽ là imposter hoặc crewmate. imposter là người luôn nói dối, cewmate là người luôn nói thật. cho m nhận xét có dạng (i, j, c) ví dụ: 1 2 imposter, tức là người chơi 1 nói người chơi 2 là imposter, như vậy nếu người chơi 2 đúng là imposter thì người chơi 1 là crewmate, và ngược lại. Tính sềElượng tối đa imposter trong game.\nRàng buộc\n1≤t≤1e4 1≤n≤2e5 0≤m≤5e5 the structure \u0026#34;i j c\u0026#34; where i and j are two distinct integers and c is a string (1≤i,j≤n; i≠j; c is either imposter or crewmate There can be multiple comments for the same pair of (i,j). It is guaranteed that the sum of all n does not exceed 2e5 and the sum of all m does not exceed 5e5. Input\n5 3 2 1 2 imposter 2 3 crewmate 5 4 1 3 crewmate 2 5 crewmate 2 4 imposter 3 4 imposter 2 2 1 2 imposter 2 1 crewmate 3 5 1 2 imposter 1 2 imposter 3 2 crewmate 3 2 crewmate 1 3 imposter 5 0 Output\n2 4 -1 2 5 Submit tại đây\nHướng giải\nQuy bài toán vềEdạng đềEthềE2n đỉnh. với người chơi i tương ứng sẽ có 2 đỉnh i và i + n, đại diện cho 2 trường hợp là crewmate và imposter. Như vậy sẽ hình thành đềEthềEvới các thành phần liên thông. Trong đó nếu tồn tại 1 thành phần liên thông mà có đỉnh i và i + n liên thông với nhau thì suy ra không tồn tại game như vậy, xuất -1. Trong hình:\nđỉnh 1 - 5 - 6 là 1 thành phần liên thông, có 2 imposter đỉnh 2 - 3 là 1 thành phần liên thông, có 0 imposter đỉnh 4 là 1 thành phần liên thông, có 1 imposter. Code\nĐềEphức tạp O(n + m) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; adj[2 * n + 1]; while(m--){ int x, y; string s; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; s; if(s[0] == \u0026#39;i\u0026#39;){ adj[x].push_back(y + n); adj[y + n].push_back(x); adj[x + n].push_back(y); adj[y].push_back(x + n); } else{ adj[x].push_back(y); adj[y].push_back(x); adj[x + n].push_back(y + n); adj[y + n].push_back(x + n); } } vector\u0026lt;bool\u0026gt; visitted(2 * n + 1, 0); int cntImposter = 0; bool ok = 0; vector\u0026lt;int\u0026gt; temp(2 * n + 1, 0); int temp1 = 0; int cnt = 0; function\u0026lt;void(int)\u0026gt; dfs = [\u0026amp;](int x){ visitted[x] = 1; temp[x] = temp1; cnt++; if(x \u0026gt; n \u0026amp;\u0026amp; temp[x - n] == temp[x]) ok = 1; else if(x \u0026lt;= n \u0026amp;\u0026amp; temp[x + n] == temp[x]) ok = 1; if(x \u0026gt; n) cntImposter++; for(auto v: adj[x]){ if(visitted[v]) continue; dfs(v); } }; int res = 0; for(int i = 1; i \u0026lt;= n; i++){ if(visitted[i] == 0 \u0026amp;\u0026amp; visitted[i + n] == 0){ temp1++; dfs(i); if(ok) break; else res += max(cnt - cntImposter, cntImposter); cntImposter = 0; cnt = 0; } } if(ok){ cout \u0026lt;\u0026lt; \u0026#34;-1\\n\u0026#34;; continue; } cout \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } "},{"id":15,"href":"/posts/2021-10-10-Peopleareleaving/","title":"Problem: People are leaving","section":"Blog","content":"Cho n người đang đứng ềEvềEtrí từ 1 tới n. Bạn phải thực hiện các truy vấn thuộc 2 loại:\n- x Người ềEvềEtrí x rời đi. ? x Người gần nhất bên phải vềEtrí x. Ràng buộc\n1≤n,m≤106 1≤x≤n Input\n5 10 ? 1 - 3 ? 3 - 2 ? 1 ? 2 - 4 ? 3 - 5 ? 3 Output\n1 4 1 4 5 -1 Submit tại đây\nHướng dẫn\nBài này cần sử dụng dsu kết hợp nén đường dẫn(path-compression) đềEkhông bềETLE. Code\nĐềEphức tạp O(nlogn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAX=1e6+1; vector\u0026lt;int\u0026gt; link(MAX+1); int find(int a){ if(a != link[a]) return link[a] = find(link[a]); return a; } void unite(int y, int z){//a\u0026lt;b z=find(z); link[y]=z; } int main(){ ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); for(int i=1; i\u0026lt;=MAX; i++) link[i]=i; int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; while(m--){ char x; int y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; if(x==\u0026#39;?\u0026#39;){ y=find(y); cout \u0026lt;\u0026lt; (y==n+1? -1: y) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else unite(y, y+1); } } "},{"id":16,"href":"/posts/2021-10-06-DynamicDiameter/","title":"Problem: Dynamic Diameter","section":"Blog","content":"Cho cây gồm n đỉnh. Hỏi nếu nối đỉnh n + 1 vào đỉnh i, thì đường kính của cây lúc này là bao nhiêu. Xuất ra kết qua cho tất cả i.\nRàng buộc\n1≤n≤3e5 Input\n3 3 2 2 1 Output\n3 2 3 Submit: tại đây\nSai 1\nTìm tâm của cây, sau đó dfs từ tâm, thu được khoảng cách từ các đỉnh đến tâm. Chọn ra 2 đỉnh có khoảng cách đến tâm xa nhất, cộng 2 khoảng cách đó lại chính là đường kính.(SAI) Ta thấy d[1] = 2, d[2] = 2. là 2 khoảng cách xa nhất đến tâm. Nhưng đường kính của cây chềElà 3.\nSai 2\nGọi path là đường dẫn có đềEdài là đường kính của cây. dfs từ 1 đỉnh bất kì đềEtìm điểm mút của path. dfs từ điểm mút đềEtìm khoẳng cách của các đỉnh đến đỉnh mút. Sau đó tính đường kính mới = max(diameter, d[i] + 1) , trước đó đã đổi d[điểm mut] = diameter.(SAI) Ta thấy d[2] = 2. Nhưng nếu đỉnh n + 1 được nối vào đỉnh 2 thì đường kính sẽ tăng thêm 1. Rõ ràng cách tính được trình bày trong thuật trên là sai.\nHướng dẫn\nGọi path là đường dẫn có đềEdài là đường kính của cây. dfs từ 1 đỉnh bất kì đềEtìm điểm mút của path. dfs từ điểm mút đềEtìm khoẳng cách của các đỉnh đến đỉnh mút. điểm có d[i] lớn nhất là điểm mút còn lại của path ta tiếp tục dfs từ điểm mút mới này, thu được mảng e với e[i] là khoảng cách từ đỉnh i tới điểm mút mới này. Đường kính mới = max(diameter, max(d[i] + 1, e[i] + 1)) Code\nĐềEphức tạp O(n) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long const int N = 3e5; int n; vector\u0026lt;int\u0026gt; adj[N + 1]; vector\u0026lt;int\u0026gt; d(N + 1, 0); void dfs(int x, int p){ for(auto v: adj[x]){ if(v == p) continue; d[v] = d[x] + 1; dfs(v, x); } } main(){ ios_base::sync_with_stdio(0);cin.tie(0); cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt; n; i++){ int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; adj[x].push_back(y); adj[y].push_back(x); } dfs(1, 0); int root = max_element(d.begin() + 1, d.end()) - d.begin(); d.assign(n + 1, 0); dfs(root, 0); int root1 = max_element(d.begin() + 1, d.end()) - d.begin(); int diameter = d[root1]; vector\u0026lt;int\u0026gt; e = d; d.assign(n + 1, 0); dfs(root1, 0); for(int i = 1; i \u0026lt;= n; i++){ cout \u0026lt;\u0026lt; max(diameter, max(d[i] + 1, e[i] + 1)) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } "},{"id":17,"href":"/posts/2021-09-20-ShiftingSort/","title":"Problem: Shifting Sort","section":"Blog","content":"Cho một mảng sềEnguyên. Hãy sắp xếp lại mảng. Được sử dụng thao tác sau không quá n lần: chọn 1 đoạn [l,r] của mảng, dịch sang trái k vềEtrí. Ví dụ 2, 5, 3 dịch sang trái 1 đơn vềEsẽ là 5, 3, 2. Xuất ra các thao tác đã thực hiện đềEthu được mảng không giảm.\nRàng buộc\n1≤t≤1000 2≤n≤50 ∁Ee9≤ai≤1e9 Input\n4 2 2 1 3 1 2 1 4 2 4 1 3 5 2 5 1 4 3 Output\n1 1 2 1 1 1 3 2 3 2 4 1 2 3 1 1 3 2 4 2 4 2 1 5 3 1 2 1 1 3 1 Submit tại đây\nHướng dẫn\nCode\nĐềEphức tạp O(nlogn) #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; typedef tree\u0026lt;int,null_type,less\u0026lt;int\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt; indexed_set; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long main(){ freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); int t; cin \u0026gt;\u0026gt; t; while(t--){ int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; res; indexed_set is; pair\u0026lt;int,int\u0026gt; a[n]; for(int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; a[i].first; a[i].second = i; } sort(a, a + n); int b[n]; for(int i = 0; i \u0026lt; n; i++){ b[a[i].second] = i; } for(int i = 0; i \u0026lt; n; i++){; int u = is.order_of_key(b[i]); if(u \u0026lt; (int)is.size()) res.push_back(make_pair(u, i)); is.insert(b[i]); } cout \u0026lt;\u0026lt; res.size() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; for(int i = 0; i \u0026lt; res.size(); i++){ cout \u0026lt;\u0026lt; res[i].first + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res[i].second + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; res[i].second - res[i].first \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } } indexed_set\r#\r#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; typedef tree\u0026lt;int,null_type,less\u0026lt;int\u0026gt;,rb_tree_tag,tree_order_statistics_node_update\u0026gt; indexed_set; #define debug(x) cerr \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; #define int long long main(){ // freopen(\u0026#34;input.txt\u0026#34;, \u0026#34;r\u0026#34;, stdin); ios_base::sync_with_stdio(0);cin.tie(0); indexed_set s; s.insert(1); s.insert(5); cout \u0026lt;\u0026lt; *s.find_by_order(0) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; *s.find_by_order(1) \u0026lt;\u0026lt; endl; // 5 cout \u0026lt;\u0026lt; *s.find_by_order(3) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; s.order_of_key(1) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; s.order_of_key(5) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; s.order_of_key(0) \u0026lt;\u0026lt; endl; // 0 cout \u0026lt;\u0026lt; s.order_of_key(3) \u0026lt;\u0026lt; endl; // 1 cout \u0026lt;\u0026lt; s.order_of_key(10) \u0026lt;\u0026lt; endl; // 2 } "},{"id":18,"href":"/docs/example/collapsed/3rd-level/4th-level/","title":"4th Level","section":"3rd Level","content":"\r4th Level of Menu\r#\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"},{"id":19,"href":"/docs/example/collapsed/3rd-level/","title":"3rd Level","section":"Collapsed","content":"\r3rd Level of Menu\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r"},{"id":20,"href":"/docs/example/hidden/","title":"Hidden","section":"Example Site","content":"\rThis page is hidden in menu\r#\rQuondam non pater est dignior ille Eurotas\r#\rLatent te facies\r#\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona\r#\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\rFronde cetera dextrae sequens pennis voce muneris\r#\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "},{"id":21,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":22,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\nExample\r#\r{{% columns [ratio=\u0026#34;1:1\u0026#34;] [class=\u0026#34;...\u0026#34;] %}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{% /columns %}} Left Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nSettings size ratio for columns\r#\r{{% columns ratio=\u0026#34;1:2\u0026#34; %}} \u0026lt;!-- begin columns block --\u0026gt; ## x1 Column Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; ## x2 Column Lorem markdownum insigne... {{% /columns %}} x1 Column\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nx2 Column\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":23,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{% details \u0026#34;Title\u0026#34; [open] %}} ## Markdown content Lorem markdownum insigne... {{% /details %}} {{% details title=\u0026#34;Title\u0026#34; open=true %}} ## Markdown content Lorem markdownum insigne... {{% /details %}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\n"},{"id":24,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{% hint [info|warning|danger] %}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{% /hint %}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\n"},{"id":25,"href":"/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":"\rMermaid Chart\r#\rMermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid initialization config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample\r#\r{{\u0026lt; mermaid [class=\u0026#34;...\u0026#34;] \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}} stateDiagram-v2\rState1: The state with a note\rnote right of State1\rImportant information! You can write\rnotes.\rend note\rState1 --\u003e State2\rnote left of State2 : This is the note to the left.\r"},{"id":26,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description. Optional param summary can be used to show or hide page summary\nExample\r#\r{{\u0026lt; section [summary] \u0026gt;}} First Page\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nSecond Page\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n"},{"id":27,"href":"/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":"\rFirst page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":28,"href":"/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":"\rSecond Page\r#\rLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":29,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{% tabs \u0026#34;id\u0026#34; %}} {{% tab \u0026#34;MacOS\u0026#34; %}} # MacOS Content {{% /tab %}} {{% tab \u0026#34;Linux\u0026#34; %}} # Linux Content {{% /tab %}} {{% tab \u0026#34;Windows\u0026#34; %}} # Windows Content {{% /tab %}} {{% /tabs %}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":30,"href":"/docs/shortcodes/katex/","title":"KaTeX","section":"Shortcodes","content":"\rKaTeX\r#\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r{{\u0026lt; katex display=true \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}} \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rDisplay Mode Example\r#\rHere is some inline example: \\(\\pi(x)\\)\r, rendered in the same line. And below is display example, having display: block \\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\rText continues here.\n"}]