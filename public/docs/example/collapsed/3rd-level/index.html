<!doctype html><html lang=en dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Câu hỏi 1: copy constructor
  #

Hãy giải thích copy constructor trong C++:

Khi nào copy constructor được gọi?
Sự khác biệt giữa shallow copy và deep copy là gì?
Bạn có thể nêu ví dụ minh họa cho trường hợp cần deep copy không?

Gợi ý cho câu hỏi copy constructor:


Copy constructor là gì?
Nó là một hàm đặc biệt được dùng để tạo ra một đối tượng mới bằng cách sao chép từ một đối tượng đã tồn tại. Copy constructor thường có dạng nhận một tham chiếu hằng (const reference) đến đối tượng cùng loại."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/example/collapsed/3rd-level/"><meta property="og:site_name" content="Aohkgnadnart Blog"><meta property="og:title" content="C++"><meta property="og:description" content="Câu hỏi 1: copy constructor#Hãy giải thích copy constructor trong C++:
Khi nào copy constructor được gọi? Sự khác biệt giữa shallow copy và deep copy là gì? Bạn có thể nêu ví dụ minh họa cho trường hợp cần deep copy không? Gợi ý cho câu hỏi copy constructor:
Copy constructor là gì?
Nó là một hàm đặc biệt được dùng để tạo ra một đối tượng mới bằng cách sao chép từ một đối tượng đã tồn tại. Copy constructor thường có dạng nhận một tham chiếu hằng (const reference) đến đối tượng cùng loại."><meta property="og:locale" content="en"><meta property="og:type" content="website"><title>C++ | Aohkgnadnart Blog</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=http://localhost:1313/docs/example/collapsed/3rd-level/><link rel=stylesheet href=/book.min.6c8b9d2a1fc95075ed7da46ca81060b39add8fff6741ac51259f768929281e2c.css integrity="sha256-bIudKh/JUHXtfaRsqBBgs5rdj/9nQaxRJZ92iSkoHiw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.13e139159b5ca30479736515fd7347cdfcfa90e8d16be14160001aec6b9261cd.js integrity="sha256-E+E5FZtcowR5c2UV/XNHzfz6kOjRa+FBYAAa7GuSYc0=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/docs/example/collapsed/3rd-level/index.xml title="Aohkgnadnart Blog"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Aohkgnadnart Blog</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></label><ul><li><a href=/zh/>Chinese</a></li><li><a href=/he/>Hebrew</a></li></ul></li></ul><ul><li class=book-section-flat><a href=/docs/example/>Trang Chủ</a><ul><li><input type=checkbox id=section-a5446993f02613041412a70215fe0f5e class=toggle checked>
<label for=section-a5446993f02613041412a70215fe0f5e class="flex justify-between"><a role=button>Interview</a></label><ul><li><input type=checkbox id=section-aeab3a266eabe870acc3c276e725ff38 class=toggle checked>
<label for=section-aeab3a266eabe870acc3c276e725ff38 class="flex justify-between"><a href=/docs/example/collapsed/3rd-level/ class=active>C++</a></label><ul></ul></li></ul></li></ul></li></ul><ul><li><a href=/posts/>Competitive Programming</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>C++</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#câu-hỏi-1-copy-constructor><strong>Câu hỏi 1: copy constructor</strong></a></li><li><a href=#câu-hỏi-2-pass-by-value-and-pass-by-reference><strong>Câu hỏi 2: pass by value and pass by reference</strong></a></li><li><a href=#câu-hỏi-3-destructor><strong>Câu hỏi 3: destructor</strong></a></li><li><a href=#câu-hỏi-4-virtual-function><strong>Câu hỏi 4: virtual function</strong></a></li><li><a href=#câu-hỏi-5-template-và-stl><strong>Câu hỏi 5: Template và STL</strong></a></li><li><a href=#câu-hỏi-6-exception-handling><strong>Câu hỏi 6: Exception Handling</strong></a></li><li><a href=#câu-hỏi-7-smart-pointers-trong-c11><strong>Câu hỏi 7: smart pointers trong C++11</strong></a><ul><li><ul><li><a href=#1-unique_ptr>1. unique_ptr</a></li><li><a href=#2-shared_ptr>2. shared_ptr</a></li><li><a href=#3-weak_ptr>3. weak_ptr</a></li><li><a href=#tổng-kết>Tổng kết</a></li></ul></li></ul></li><li><a href=#câu-hỏi-8-operator-overloading><strong>Câu hỏi 8: operator overloading</strong></a></li><li><a href=#câu-hỏi-9-constructor-initialization-list><strong>Câu hỏi 9: constructor initialization list</strong></a></li><li><a href=#câu-hỏi-9-raii-resource-acquisition-is-initialization><strong>Câu hỏi 9: RAII (Resource Acquisition Is Initialization)</strong></a></li><li><a href=#câu-hỏi-10-stack-và-heap><strong>Câu hỏi 10: stack và heap</strong></a><ul><li><ul><li><a href=#stack>Stack</a></li><li><a href=#heap>Heap</a></li></ul></li></ul></li><li><a href=#câu-hỏi-11-const-correctness><strong>Câu hỏi 11: const-correctness</strong></a></li><li><a href=#câu-hỏi-12-static-members><strong>Câu hỏi 12: static members</strong></a></li><li><a href=#câu-hỏi-13-inline-functions><strong>Câu hỏi 13: inline functions</strong></a></li><li><a href=#câu-hỏi-14-các-loại-ép-kiểu-type-casting><strong>Câu hỏi 14: các loại ép kiểu (type casting)</strong></a><ul><li><ul><li><a href=#1-static_cast>1. static_cast</a></li><li><a href=#2-dynamic_cast>2. dynamic_cast</a></li><li><a href=#3-reinterpret_cast>3. reinterpret_cast</a></li><li><a href=#4-const_cast>4. const_cast</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=câu-hỏi-1-copy-constructor><strong>Câu hỏi 1: copy constructor</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-1-copy-constructor>#</a></h1><p><em>Hãy giải thích copy constructor trong C++:</em></p><ul><li>Khi nào copy constructor được gọi?</li><li>Sự khác biệt giữa shallow copy và deep copy là gì?</li><li>Bạn có thể nêu ví dụ minh họa cho trường hợp cần deep copy không?</li></ul><p>Gợi ý cho câu hỏi copy constructor:</p><ul><li><p><strong>Copy constructor là gì?</strong><br>Nó là một hàm đặc biệt được dùng để tạo ra một đối tượng mới bằng cách sao chép từ một đối tượng đã tồn tại. Copy constructor thường có dạng nhận một tham chiếu hằng (const reference) đến đối tượng cùng loại.</p></li><li><p><strong>Khi nào nó được gọi?</strong></p><ul><li>Khi bạn khởi tạo một đối tượng bằng cách gán nó với một đối tượng khác (ví dụ: MyClass a = b;).</li><li>Khi truyền đối tượng theo giá trị vào hàm.</li><li>Khi hàm trả về một đối tượng theo giá trị.</li></ul></li><li><p><strong>Shallow copy vs Deep copy:</strong></p><ul><li><em>Shallow copy</em> chỉ sao chép các giá trị (bao gồm các con trỏ) mà không sao chép dữ liệu mà chúng trỏ tới. Điều này có thể dẫn đến rủi ro như lỗi giải phóng bộ nhớ (double deletion) nếu cả hai đối tượng cùng trỏ đến cùng một vùng nhớ.</li><li><em>Deep copy</em> sao chép toàn bộ dữ liệu, tức là tạo ra bản sao mới cho vùng nhớ mà con trỏ trỏ tới. Điều này giúp mỗi đối tượng có bộ nhớ riêng biệt và an toàn hơn.</li></ul></li><li><p><strong>Ví dụ minh họa:</strong><br>Giả sử bạn có một lớp MyString với thành viên là con trỏ char*:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyString</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> data;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor thông thường
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MyString(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> str) {
</span></span><span style=display:flex><span>        data <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[strlen(str) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        strcpy(data, str);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Copy constructor (deep copy)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MyString(<span style=color:#66d9ef>const</span> MyString<span style=color:#f92672>&amp;</span> other) {
</span></span><span style=display:flex><span>        data <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[strlen(other.data) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        strcpy(data, other.data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>MyString() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>delete</span>[] data;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Trong ví dụ này, copy constructor tạo ra một mảng mới để sao chép nội dung của <code>other.data</code>, do đó tránh được việc cả hai đối tượng cùng trỏ đến cùng một vùng nhớ.</p></li></ul><h1 id=câu-hỏi-2-pass-by-value-and-pass-by-reference><strong>Câu hỏi 2: pass by value and pass by reference</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-2-pass-by-value-and-pass-by-reference>#</a></h1><p><em>Hãy giải thích sự khác biệt giữa truyền tham số theo giá trị (pass by value) và truyền tham số theo tham chiếu (pass by reference) trong C++.</em></p><ul><li>Ưu và nhược điểm của từng phương pháp là gì?</li><li>Xin nêu ví dụ minh họa cho từng trường hợp.</li></ul><p>Đúng là khi truyền theo giá trị, hàm nhận được một bản sao của đối số. Tuy nhiên, thuật ngữ &ldquo;deep copy&rdquo; không phải lúc nào cũng đúng với pass by value. Thông thường:</p><ul><li><p><strong>Pass by Value:</strong><br>Khi bạn truyền theo giá trị, một bản sao của đối số được tạo ra bằng cách sử dụng copy constructor (đối với các đối tượng) hoặc sao chép trực tiếp (với các kiểu dữ liệu cơ bản).</p><ul><li>Điều này có nghĩa là bất kỳ thay đổi nào bên trong hàm không ảnh hưởng đến biến gốc bên ngoài.</li><li>Nếu đối tượng chứa con trỏ, copy constructor mặc định có thể tạo ra một bản sao &ldquo;nông&rdquo; (shallow copy) nếu không được tự định nghĩa lại để thực hiện &ldquo;deep copy&rdquo;.</li><li>Ví dụ, với kiểu dữ liệu cơ bản (như int), bạn chỉ đơn giản sao chép giá trị.</li></ul></li><li><p><strong>Pass by Reference:</strong><br>Khi bạn truyền theo tham chiếu, hàm nhận được một &ldquo;bí danh&rdquo; cho biến gốc (không tạo ra bản sao nào).</p><ul><li>Do đó, bất kỳ thay đổi nào bên trong hàm sẽ ảnh hưởng trực tiếp đến biến gốc.</li><li>Thuật ngữ &ldquo;shallow copy&rdquo; không hoàn toàn áp dụng vì không có quá trình sao chép nào xảy ra cả.</li></ul></li></ul><p><strong>Ví dụ minh họa:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>incrementByValue</span>(<span style=color:#66d9ef>int</span> a) {
</span></span><span style=display:flex><span>    a<span style=color:#f92672>++</span>;  <span style=color:#75715e>// Thay đổi chỉ xảy ra trên bản sao
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Inside incrementByValue: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>incrementByReference</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a) {
</span></span><span style=display:flex><span>    a<span style=color:#f92672>++</span>;  <span style=color:#75715e>// Thay đổi ảnh hưởng đến biến gốc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Inside incrementByReference: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    incrementByValue(x);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;After incrementByValue, x = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// x vẫn là 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    incrementByReference(x);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;After incrementByReference, x = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// x tăng thành 11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Tóm lại:</strong></p><ul><li>Pass by value tạo ra một bản sao (với copy constructor cho các đối tượng), do đó thay đổi bên trong hàm không ảnh hưởng đến đối tượng gốc.</li><li>Pass by reference không tạo ra bản sao nào; hàm làm việc trực tiếp với biến gốc.</li></ul><h1 id=câu-hỏi-3-destructor><strong>Câu hỏi 3: destructor</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-3-destructor>#</a></h1><p><em>Hãy giải thích về destructor trong C++:</em></p><ul><li><strong>(a)</strong> Khi nào destructor được gọi?</li><li><strong>(b)</strong> Tại sao destructor không thể được overload?</li><li><strong>(c)</strong> Bạn hãy đưa ra một ví dụ minh họa cho một lớp có destructor.</li></ul><p>Đúng, destructor được gọi khi đối tượng kết thúc vòng đời của nó – ví dụ, khi đối tượng ra khỏi phạm vi hoặc khi delete được gọi cho đối tượng được cấp phát động.</p><p>Ngoài ra, hãy nhớ những điểm sau:</p><ol><li><p><strong>Thời điểm gọi destructor:</strong></p><ul><li>Đối với các biến cục bộ, destructor được gọi khi chương trình thoát khỏi khối (scope) chứa đối tượng đó.</li><li>Đối với đối tượng được cấp phát động bằng new, destructor được gọi khi bạn gọi delete.</li></ul></li><li><p><strong>Tại sao destructor không thể overload:</strong></p><ul><li>Destructor không nhận đối số nên không thể định nghĩa nhiều phiên bản khác nhau (không có overloading). Mỗi lớp chỉ có duy nhất một destructor, và đó là điều cần thiết để đảm bảo rằng quá trình huỷ đối tượng được thực hiện nhất quán.</li></ul></li><li><p><strong>Ví dụ minh họa:</strong></p></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MyClass() {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Constructor is called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Destructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>MyClass() {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Destructor is called.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        MyClass obj; <span style=color:#75715e>// Khi ra khỏi khối này, obj sẽ bị hủy và destructor được gọi.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Out of block.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ trên, khi chương trình thực thi khối bên trong main, đối tượng <code>obj</code> được tạo ra và sau khi khối kết thúc, destructor của <code>obj</code> được gọi tự động.</p><h1 id=câu-hỏi-4-virtual-function><strong>Câu hỏi 4: virtual function</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-4-virtual-function>#</a></h1><p><em>Hãy giải thích về hàm ảo (virtual function) trong C++:</em></p><ul><li><p>Tại sao chúng cần thiết trong lập trình hướng đối tượng?</p></li><li><p>Làm thế nào chúng hỗ trợ tính đa hình?</p></li><li><p>Xin cho ví dụ minh họa.</p></li><li><p><strong>Mục đích của hàm ảo:</strong><br>Hàm ảo được sử dụng để cho phép các lớp con ghi đè (override) một cách linh hoạt. Khi bạn gọi một hàm thông qua con trỏ hoặc tham chiếu của lớp cơ sở, nếu hàm được khai báo là virtual, C++ sẽ thực hiện “dynamic binding” (liên kết động) và gọi phiên bản của hàm thuộc lớp con thực sự mà con trỏ/truyền tham chiếu đó đang trỏ tới. Ngược lại, nếu không khai báo virtual, C++ sẽ sử dụng “static binding” (liên kết tĩnh) và gọi hàm của lớp cơ sở mặc dù đối tượng thực sự là của lớp con.</p></li><li><p><strong>Ví dụ minh họa:</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> display() { <span style=color:#75715e>// Hàm ảo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base class display&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> display() <span style=color:#66d9ef>override</span> { <span style=color:#75715e>// Ghi đè hàm ảo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derived class display&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Base<span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived();  <span style=color:#75715e>// Con trỏ kiểu Base nhưng trỏ đến đối tượng Derived
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr<span style=color:#f92672>-&gt;</span>display();  <span style=color:#75715e>// In ra: &#34;Derived class display&#34; nhờ dynamic binding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ trên, mặc dù con trỏ <code>ptr</code> có kiểu <code>Base*</code>, nhưng nó trỏ đến đối tượng của lớp <code>Derived</code>. Do hàm <code>display()</code> được khai báo là virtual, nên phiên bản của lớp <code>Derived</code> được gọi khi <code>ptr->display()</code> được thực thi.</p><h1 id=câu-hỏi-5-template-và-stl><strong>Câu hỏi 5: Template và STL</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-5-template-v%c3%a0-stl>#</a></h1><p><em>Hãy giải thích về template và STL trong C++:</em></p><ul><li>Template là gì và tại sao chúng hữu ích?</li><li>STL (Standard Template Library) là gì? Bạn có thể nêu ví dụ minh họa sử dụng một container trong STL không?</li></ul><p>Đúng vậy. Template cho phép bạn viết hàm hoặc lớp mà không cần định nghĩa trước kiểu dữ liệu cụ thể – kiểu dữ liệu sẽ được xác định khi hàm hoặc lớp được sử dụng. Điều này giúp tạo ra một dạng &ldquo;đa hình&rdquo; ở cấp độ compile-time (parametric polymorphism).</p><p>STL (Standard Template Library) là thư viện tiêu chuẩn của C++ được xây dựng dựa trên template, cung cấp các container (ví dụ: vector, list, map…), các thuật toán (sort, search, …) và iterator giúp bạn làm việc với dữ liệu một cách hiệu quả và an toàn.</p><p><strong>Ví dụ sử dụng vector trong STL:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Khởi tạo vector chứa các số nguyên
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> numbers <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Thêm một phần tử vào vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    numbers.push_back(<span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Duyệt và in các phần tử trong vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> n : numbers) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> n <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; &#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ này, vector là một container được định nghĩa theo kiểu template, cho phép bạn lưu trữ và thao tác với các phần tử kiểu int. Bạn có thể sử dụng cùng một container cho các kiểu dữ liệu khác nếu cần.</p><h1 id=câu-hỏi-6-exception-handling><strong>Câu hỏi 6: Exception Handling</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-6-exception-handling>#</a></h1><p>Hãy cho biết bạn hiểu exception handling trong C++ như thế nào:</p><ul><li>Tại sao chúng ta cần sử dụng cơ chế xử lý ngoại lệ?</li><li>Hãy giải thích cách hoạt động của khối try-catch và khi nào bạn nên sử dụng throw.</li><li>Bạn có thể nêu một ví dụ đơn giản minh họa việc bắt và xử lý ngoại lệ không?</li></ul><p>Xin mời bạn trả lời!</p><p>Đúng vậy, xử lý ngoại lệ cho phép chương trình không bị dừng đột ngột khi gặp lỗi, mà thay vào đó chúng ta có thể xử lý một cách có kiểm soát. Một số điểm bổ sung bạn có thể nhấn mạnh:</p><ul><li><p><strong>Mục đích:</strong><br>Giúp chương trình hoạt động ổn định hơn, bằng cách cho phép xử lý các tình huống lỗi (exceptions) thay vì để chương trình crash.</p></li><li><p><strong>Cơ chế hoạt động:</strong></p><ul><li><strong>try block:</strong> Chứa đoạn mã có khả năng gây ra ngoại lệ.</li><li><strong>throw:</strong> Khi gặp điều kiện lỗi, ta sử dụng throw để ném ra một đối tượng ngoại lệ.</li><li><strong>catch block:</strong> Bắt và xử lý ngoại lệ. Bạn có thể có nhiều khối catch để xử lý các loại ngoại lệ khác nhau.</li></ul></li><li><p><strong>Ví dụ minh họa:</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdexcept&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>divide</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Division by zero error!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> a <span style=color:#f92672>/</span> b <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        divide(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>runtime_error <span style=color:#f92672>&amp;</span>e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Caught exception: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Program continues normally...&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ trên, nếu b == 0, hàm sẽ ném ra ngoại lệ và khối catch sẽ bắt, hiển thị thông báo lỗi mà không làm dừng chương trình.</p><p>Dưới đây là một ví dụ khác về cách sử dụng exception handling trong C++ với nhiều khối catch để xử lý các loại ngoại lệ khác nhau:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdexcept&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Hàm thực hiện phép chia an toàn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>safeDivide</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Nếu mẫu số bằng 0, ném ra ngoại lệ invalid_argument
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>invalid_argument(<span style=color:#e6db74>&#34;Cannot divide by zero!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>/</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Thực hiện một phép chia hợp lệ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> result1 <span style=color:#f92672>=</span> safeDivide(<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;20 / 4 = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result1 <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Thực hiện một phép chia không hợp lệ (mẫu số = 0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>double</span> result2 <span style=color:#f92672>=</span> safeDivide(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;10 / 0 = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result2 <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>invalid_argument <span style=color:#f92672>&amp;</span>ex) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Bắt và xử lý ngoại lệ invalid_argument
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Invalid argument error: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ex.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (...) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Bắt mọi loại ngoại lệ khác nếu có
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;An unknown error occurred.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Program continues after exception handling.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Hàm <code>safeDivide</code> kiểm tra nếu mẫu số bằng 0, nó sẽ ném ra một ngoại lệ kiểu <code>std::invalid_argument</code> với thông báo lỗi.</li><li>Trong hàm <code>main()</code>, khối <code>try</code> chứa các lời gọi hàm có thể gây ra ngoại lệ. Nếu phép chia nào đó không hợp lệ (ví dụ, chia cho 0), thì khối <code>catch</code> tương ứng sẽ bắt ngoại lệ và in ra thông báo lỗi.</li><li>Nếu có ngoại lệ khác không được xác định rõ, khối catch thứ hai với dấu <code>...</code> sẽ bắt tất cả các ngoại lệ còn lại.</li><li>Sau khi xử lý ngoại lệ, chương trình vẫn tiếp tục chạy mà không bị dừng đột ngột.</li></ul><p>Ví dụ này minh họa cách xử lý ngoại lệ khi gặp lỗi chia cho 0 và cho thấy cách chương trình tiếp tục chạy sau khi bắt lỗi.</p><details><summary>Trong trường hợp không có throw thì sao?</summary><div class=markdown-inner><p>Nếu trong hàm không có lệnh <code>throw</code> khi gặp lỗi, thì không có ngoại lệ nào được ném ra và do đó các khối <code>catch</code> sẽ không được thực thi. Điều này có nghĩa là chương trình sẽ tiếp tục chạy bình thường (hoặc theo cách xử lý lỗi khác mà bạn định nghĩa, ví dụ trả về giá trị lỗi) mà không sử dụng cơ chế exception handling.</p><p>Ví dụ, nếu bạn có một hàm chia mà không kiểm tra mẫu số và không ném ngoại lệ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>unsafeDivide</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Không kiểm tra b == 0, không throw ngoại lệ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>/</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> result <span style=color:#f92672>=</span> unsafeDivide(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// Đây có thể dẫn đến undefined behavior
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong trường hợp này, nếu <code>b</code> bằng 0, hành vi của chương trình không được xác định (có thể là crash, NaN, hoặc giá trị bất kỳ) vì không có cơ chế exception nào được sử dụng để xử lý tình huống lỗi.</p><p>Tóm lại, không sử dụng <code>throw</code> có nghĩa là bạn không tận dụng được cơ chế exception handling của C++ để kiểm soát lỗi, và bạn cần phải xử lý lỗi theo cách khác (ví dụ, kiểm tra điều kiện lỗi trước khi thực hiện phép toán).</p></div></details><details><summary>Không phải cứ đặt đoạn code có thể gây lỗi vào try trong try catch là được à?</summary><div class=markdown-inner><p>Đúng vậy, try-catch chỉ hoạt động khi có exception được ném ra bằng lệnh <code>throw</code>. Nếu bên trong hàm bạn không có lệnh <code>throw</code> khi gặp lỗi, thì dù bạn đặt đoạn code đó trong khối try, catch cũng không bắt được gì.</p><p>Ví dụ, nếu bạn có hàm sau không ném ngoại lệ khi chia cho 0:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>unsafeDivide</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>/</span> b;  <span style=color:#75715e>// Nếu b == 0, hành vi không xác định, nhưng không có throw
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>double</span> result <span style=color:#f92672>=</span> unsafeDivide(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Result: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>exception<span style=color:#f92672>&amp;</span> e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Exception caught: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ trên, vì <code>unsafeDivide</code> không sử dụng <code>throw</code> khi b == 0 nên không có ngoại lệ nào được ném ra và do đó khối <code>catch</code> không bao giờ thực hiện, mặc dù lỗi có thể xảy ra (ví dụ: chia cho 0 gây ra undefined behavior).</p><p>Nói chung, try-catch chỉ có ích nếu các tình huống lỗi được xử lý thông qua cơ chế ném ngoại lệ. Nếu bạn không có lệnh <code>throw</code> thì try-catch sẽ không “bắt” được bất cứ lỗi nào.</p></div></details><details><summary>Có vẻ khác java nhỉ, lỡ như có những lỗi tôi không lường trước để đặt throw thì sao?</summary><div class=markdown-inner><p>Đúng vậy, khác với Java, C++ không tự động ném ngoại lệ cho mọi lỗi runtime. Trong Java, khi có lỗi như null pointer, index out of bounds, hoặc lỗi chia cho 0, JVM sẽ tự ném các ngoại lệ tương ứng (ví dụ, NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException) để bạn có thể bắt và xử lý.</p><p>Trong C++ thì phần lớn lỗi runtime (như chia cho 0 hay truy cập ngoài mảng) sẽ dẫn đến undefined behavior, crash hoặc lỗi hệ thống mà không có exception nào được ném ra tự động nếu bạn không chủ động kiểm tra và throw ngoại lệ. Điều này có nghĩa là:</p><ul><li>Nếu bạn không dự đoán được lỗi nào có thể xảy ra và không đặt lệnh throw, thì try-catch sẽ không bao giờ bắt được lỗi đó.</li><li>Vì thế, khi viết code C++, bạn cần chủ động kiểm tra các điều kiện lỗi (ví dụ, kiểm tra mẫu số khác 0 trước khi chia) và ném ngoại lệ bằng lệnh throw nếu cần thiết.</li></ul><p>Một số hàm trong thư viện chuẩn của C++ có thể ném ngoại lệ (ví dụ, khi new không thể cấp phát bộ nhớ, nó sẽ ném std::bad_alloc). Nhưng đối với các lỗi khác, bạn cần tự xử lý.</p><p>Ví dụ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>safeDivide</span>(<span style=color:#66d9ef>double</span> a, <span style=color:#66d9ef>double</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Nếu bạn không throw, thì lỗi chia cho 0 sẽ không được xử lý qua cơ chế ngoại lệ.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Division by zero error!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>/</span> b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nếu không có lệnh throw, và bạn gọi <code>safeDivide(10, 0)</code>, hành vi của chương trình có thể không xác định và khối catch sẽ không nhận được ngoại lệ nào.</p><p>Tóm lại, trong C++ bạn phải chủ động phát hiện và ném ngoại lệ khi cần, vì không giống như Java, hệ thống không tự động xử lý nhiều lỗi runtime thông qua cơ chế ngoại lệ.</p></div></details><h1 id=câu-hỏi-7-smart-pointers-trong-c11><strong>Câu hỏi 7: smart pointers trong C++11</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-7-smart-pointers-trong-c11>#</a></h1><p><em>Hãy giải thích về smart pointers trong C++11 và nêu sự khác biệt giữa <code>unique_ptr</code>, <code>shared_ptr</code> và <code>weak_ptr</code>.</em></p><ul><li>Tại sao smart pointers lại hữu ích trong quản lý bộ nhớ?</li><li>Ví dụ minh họa khi nào nên sử dụng từng loại.</li></ul><p>Smart pointers là các lớp template trong C++ (được định nghĩa trong &lt;memory>) nhằm tự động quản lý bộ nhớ của các đối tượng được cấp phát động, giúp tránh rò rỉ bộ nhớ và giảm bớt gánh nặng của việc gọi delete thủ công.</p><p>Dưới đây là phân tích và ví dụ cho ba loại smart pointers cơ bản:</p><hr><h3 id=1-unique_ptr>1. unique_ptr
<a class=anchor href=#1-unique_ptr>#</a></h3><ul><li><strong>Đặc điểm:</strong><ul><li><strong>Chủ sở hữu độc quyền:</strong> Chỉ có một unique_ptr sở hữu đối tượng tại một thời điểm.</li><li>Không thể sao chép (copy) nhưng có thể di chuyển (move).</li></ul></li><li><strong>Khi nào sử dụng:</strong><ul><li>Khi bạn muốn đảm bảo rằng chỉ có một đối tượng sở hữu dữ liệu đó, và dữ liệu sẽ được giải phóng khi unique_ptr ra khỏi phạm vi.</li></ul></li><li><strong>Ví dụ:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Tạo unique_ptr quản lý một số nguyên
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    unique_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> up1(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>10</span>));
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>up1 <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Di chuyển chủ sở hữu từ up1 sang up2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    unique_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> up2 <span style=color:#f92672>=</span> move(up1);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Bây giờ, up1 không còn sở hữu gì (nó nullptr)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>up1)
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;up1 không còn sở hữu đối tượng nào.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị từ up2: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>up2 <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=2-shared_ptr>2. shared_ptr
<a class=anchor href=#2-shared_ptr>#</a></h3><ul><li><strong>Đặc điểm:</strong><ul><li><strong>Chủ sở hữu chia sẻ:</strong> Nhiều shared_ptr có thể sở hữu cùng một đối tượng.</li><li>Dữ liệu sẽ được giải phóng khi số lượng shared_ptr sở hữu đối tượng giảm về 0 (đếm số lần tham chiếu).</li></ul></li><li><strong>Khi nào sử dụng:</strong><ul><li>Khi nhiều phần của chương trình cần chia sẻ quyền sở hữu đối tượng.</li></ul></li><li><strong>Ví dụ:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    shared_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> sp1(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>20</span>));
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>sp1 <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, số lượng tham chiếu: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> sp1.use_count() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// use_count = 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sao chép shared_ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    shared_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> sp2 <span style=color:#f92672>=</span> sp1;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Sau khi sao chép, số lượng tham chiếu: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> sp1.use_count() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// use_count = 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=3-weak_ptr>3. weak_ptr
<a class=anchor href=#3-weak_ptr>#</a></h3><ul><li><strong>Đặc điểm:</strong><ul><li><strong>Con trỏ không sở hữu:</strong> weak_ptr không tăng số lượng tham chiếu của đối tượng, giúp tránh vòng tham chiếu (circular reference) trong trường hợp shared_ptr.</li><li>Nó có thể &ldquo;truy cập&rdquo; đối tượng nếu đối tượng vẫn tồn tại bằng cách dùng phương thức <code>lock()</code>, trả về shared_ptr.</li></ul></li><li><strong>Khi nào sử dụng:</strong><ul><li>Khi bạn cần một &ldquo;tham chiếu không sở hữu&rdquo; đến đối tượng được quản lý bởi shared_ptr.</li></ul></li><li><strong>Ví dụ:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    shared_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> sp(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>30</span>));
</span></span><span style=display:flex><span>    weak_ptr<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> wp <span style=color:#f92672>=</span> sp;  <span style=color:#75715e>// wp không tăng use_count
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Số lượng tham chiếu từ sp: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> sp.use_count() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// use_count vẫn là 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Kiểm tra xem đối tượng có tồn tại không
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>auto</span> spt <span style=color:#f92672>=</span> wp.lock()) {  <span style=color:#75715e>// lock() trả về shared_ptr nếu đối tượng còn tồn tại
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị từ weak_ptr: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>spt <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Đối tượng đã bị giải phóng.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=tổng-kết>Tổng kết
<a class=anchor href=#t%e1%bb%95ng-k%e1%ba%bft>#</a></h3><ul><li><strong>unique_ptr:</strong> Sở hữu độc quyền, không cho phép copy, chỉ cho phép move.</li><li><strong>shared_ptr:</strong> Cho phép nhiều con trỏ cùng sở hữu đối tượng, sử dụng đếm số tham chiếu để quản lý thời gian sống của đối tượng.</li><li><strong>weak_ptr:</strong> Không sở hữu đối tượng, dùng để tham chiếu mà không tăng số đếm tham chiếu, hữu ích để phá vỡ vòng lặp trong shared_ptr.</li></ul><h1 id=câu-hỏi-8-operator-overloading><strong>Câu hỏi 8: operator overloading</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-8-operator-overloading>#</a></h1><p><em>Hãy giải thích về operator overloading trong C++:</em></p><ul><li>Operator overloading là gì và tại sao chúng hữu ích?</li><li>Bạn hãy cho ví dụ minh họa bằng cách nạp chồng toán tử cộng (+) cho một lớp biểu diễn số phức.</li></ul><p>Operator overloading cho phép bạn “tái định nghĩa” các toán tử (như +, -, *, &#171;, …) để chúng hoạt động theo cách bạn muốn với các đối tượng của lớp bạn tự định nghĩa. Điều này giúp mã trở nên trực quan hơn, vì bạn có thể viết code giống như các kiểu dữ liệu cơ bản, thay vì phải gọi các hàm thành viên đặc biệt để thực hiện các phép toán.</p><p><strong>Một số điểm cần lưu ý:</strong></p><ul><li><p><strong>Mục đích:</strong></p><ul><li>Làm cho code của bạn dễ đọc và dễ hiểu hơn khi làm việc với các đối tượng (ví dụ: khi cộng hai số phức, bạn có thể viết <code>a + b</code> thay vì <code>a.add(b)</code>).</li></ul></li><li><p><strong>Cách hoạt động:</strong></p><ul><li>Bạn có thể định nghĩa lại toán tử bằng cách tạo một hàm thành viên (hoặc hàm bạn, friend function) với cú pháp đặc biệt, ví dụ: <code>Complex operator+(const Complex &amp;other) const</code>.</li></ul></li><li><p><strong>Lưu ý:</strong></p><ul><li>Không nên lạm dụng operator overloading; hãy đảm bảo rằng việc nạp chồng toán tử làm cho code trở nên trực quan và không gây nhầm lẫn.</li><li>Các toán tử được nạp chồng phải tuân theo ý nghĩa ban đầu của chúng, nếu không sẽ làm code khó hiểu.</li></ul></li></ul><p><strong>Ví dụ minh họa: Nạp chồng toán tử cộng cho lớp số phức</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Complex</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> real;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> imag;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor với tham số mặc định
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Complex(<span style=color:#66d9ef>double</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>double</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>:</span> real(r), imag(i) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm nạp chồng toán tử +: trả về tổng của hai số phức
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Complex <span style=color:#66d9ef>operator</span><span style=color:#f92672>+</span>(<span style=color:#66d9ef>const</span> Complex <span style=color:#f92672>&amp;</span>other) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Complex</span>(real <span style=color:#f92672>+</span> other.real, imag <span style=color:#f92672>+</span> other.imag);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm hiển thị
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> real <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; + &#34;</span> <span style=color:#f92672>&lt;&lt;</span> imag <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i)&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Complex c1(<span style=color:#ae81ff>3.5</span>, <span style=color:#ae81ff>2.0</span>);
</span></span><span style=display:flex><span>    Complex c2(<span style=color:#ae81ff>1.5</span>, <span style=color:#ae81ff>4.5</span>);
</span></span><span style=display:flex><span>    Complex c3 <span style=color:#f92672>=</span> c1 <span style=color:#f92672>+</span> c2; <span style=color:#75715e>// Sử dụng toán tử nạp chồng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Tổng của &#34;</span>;
</span></span><span style=display:flex><span>    c1.display();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; và &#34;</span>;
</span></span><span style=display:flex><span>    c2.display();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; là &#34;</span>;
</span></span><span style=display:flex><span>    c3.display();
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Lớp <code>Complex</code> định nghĩa hai biến thành viên <code>real</code> và <code>imag</code> để lưu phần thực và phần ảo.</li><li>Hàm thành viên <code>operator+</code> nhận một đối tượng <code>Complex</code> khác và trả về một đối tượng mới có giá trị bằng tổng của phần thực và phần ảo tương ứng.</li><li>Khi sử dụng <code>c1 + c2</code>, hàm này được gọi để tính tổng, giúp code trở nên tự nhiên và dễ đọc.</li></ul><details><summary>Còn toán từ `&lt;&lt;` để cập ở trên là dịch bit hay cout vậy ? ví dụ</summary><div class=markdown-inner><p>Toán tử &ldquo;&#171;&rdquo; có hai ý nghĩa chính trong C++:</p><ol><li><strong>Bit-shift operator:</strong> Dùng để dịch bit sang bên trái.</li><li><strong>Stream insertion operator:</strong> Dùng với các đối tượng ostream (như cout) để xuất dữ liệu ra màn hình.</li></ol><p>Khi bạn tái định nghĩa (overload) toán tử &ldquo;&#171;&rdquo; cho lớp của mình, mục đích thường là để tạo ra một cách thuận tiện để in thông tin đối tượng ra output stream.</p><p>Ví dụ, giả sử bạn có lớp số phức (Complex), bạn có thể overload toán tử &ldquo;&#171;&rdquo; như sau:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Complex</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> real, imag;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor với tham số mặc định
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Complex(<span style=color:#66d9ef>double</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>double</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>:</span> real(r), imag(i) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Overload toán tử &lt;&lt; để xuất đối tượng Complex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Hàm friend giúp truy cập trực tiếp các thành viên private của lớp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>friend</span> ostream<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>&lt;&lt;</span>(ostream<span style=color:#f92672>&amp;</span> os, <span style=color:#66d9ef>const</span> Complex<span style=color:#f92672>&amp;</span> c) {
</span></span><span style=display:flex><span>        os <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;(&#34;</span> <span style=color:#f92672>&lt;&lt;</span> c.real <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; + &#34;</span> <span style=color:#f92672>&lt;&lt;</span> c.imag <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i)&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> os;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Complex c1(<span style=color:#ae81ff>3.5</span>, <span style=color:#ae81ff>2.0</span>);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Số phức: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> c1 <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Hàm <code>operator&lt;&lt;</code> được khai báo là friend trong lớp <code>Complex</code> để có thể truy cập trực tiếp các thành viên private (<code>real</code> và <code>imag</code>).</li><li>Hàm này nhận vào một đối tượng <code>ostream</code> (thường là <code>cout</code>) và một đối tượng <code>Complex</code> cần xuất.</li><li>Nó chèn thông tin của đối tượng vào stream và trả về stream đó, cho phép chaining (chuỗi các thao tác chèn).</li></ul><p>Qua đó, bạn có thể dùng <code>cout &lt;&lt; c1</code> để xuất thông tin của đối tượng <code>c1</code> theo định dạng mong muốn.</p></div></details><h1 id=câu-hỏi-9-constructor-initialization-list><strong>Câu hỏi 9: constructor initialization list</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-9-constructor-initialization-list>#</a></h1><p><em>Hãy giải thích về constructor initialization list trong C++ và nêu những lợi ích của nó. Khi nào bạn bắt buộc phải sử dụng constructor initialization list?<br>Ví dụ minh họa:</em></p><p>Constructor initialization list (danh sách khởi tạo trong constructor) không phải là constructor có nhiều đối số, mà là cú pháp đặc biệt trong constructor để <strong>khởi tạo các thành viên của lớp ngay trước khi thân hàm được thực thi</strong>.</p><p><strong>Điểm chính:</strong></p><ul><li><p><strong>Cú pháp:</strong><br>Sau dấu hai chấm (:) trong định nghĩa constructor, bạn liệt kê các thành viên cần khởi tạo cùng với giá trị khởi tạo của chúng.<br>Ví dụ:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> b;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor sử dụng initialization list để khởi tạo &#39;a&#39; và &#39;b&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    MyClass(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) <span style=color:#f92672>:</span> a(x), b(y) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// thân hàm constructor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></li><li><p><strong>Lợi ích:</strong></p><ul><li><strong>Hiệu quả:</strong> Các thành viên được khởi tạo trực tiếp với giá trị cần thiết, thay vì được tạo mặc định rồi sau đó gán lại trong thân hàm.</li><li><strong>Bắt buộc với const và reference:</strong> Nếu lớp có thành viên là <code>const</code> hoặc là tham chiếu, bạn bắt buộc phải khởi tạo chúng thông qua initialization list.</li><li><strong>Đối với các lớp con không có constructor mặc định:</strong> Nếu thành viên là đối tượng của một lớp khác mà không có constructor mặc định, bạn cần sử dụng initialization list để khởi tạo chúng.</li></ul></li></ul><p>Như vậy, constructor initialization list giúp bạn kiểm soát quá trình khởi tạo của các thành viên một cách hiệu quả và an toàn, đặc biệt khi làm việc với các thành viên không thể thay đổi sau khi khởi tạo (const, reference) hoặc các thành viên cần khởi tạo đặc biệt.</p><details><summary>Nó khác gì với contrucstor nhiều tham số, ví dụ</summary><div class=markdown-inner><p>Constructor initialization list không phải là một kiểu constructor riêng biệt hay chỉ là constructor có nhiều tham số; nó là <strong>cách thức bạn khởi tạo các thành viên của lớp ngay khi đối tượng được tạo ra</strong>, thay vì gán giá trị cho các thành viên đó trong thân hàm constructor.</p><p>Ví dụ, giả sử bạn có lớp như sau:</p><p><strong>Cách 1: Sử dụng assignment trong thân hàm constructor</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor có tham số
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Example(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Thành viên &#39;a&#39; được khởi tạo mặc định (không được chỉ định giá trị cụ thể) rồi sau đó được gán giá trị.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        a <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Ở cách này, trước khi thân hàm constructor được thực thi, thành viên <code>a</code> đã được khởi tạo theo cách mặc định (với kiểu int, có thể là không xác định nếu không có giá trị khởi tạo mặc định) và sau đó mới được gán giá trị x bên trong thân hàm.</p><p><strong>Cách 2: Sử dụng constructor initialization list</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Example</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor với initialization list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Example(<span style=color:#66d9ef>int</span> x) <span style=color:#f92672>:</span> a(x) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Thân hàm có thể rỗng hoặc thực hiện các công việc khác
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Ở cách này, thành viên <code>a</code> được khởi tạo ngay với giá trị x trước khi thân hàm constructor thực thi. Điều này có lợi vì:</p><ul><li>Nó <strong>tránh được việc khởi tạo mặc định rồi sau đó gán lại</strong>, giúp hiệu quả hơn.</li><li>Đối với các thành viên là const hoặc tham chiếu, bạn <strong>bắt buộc phải sử dụng initialization list</strong> vì chúng không thể được gán lại sau khi khởi tạo.</li></ul><p><strong>Tóm lại:</strong></p><ul><li><strong>Constructor nhiều tham số:</strong> Chỉ đơn thuần là constructor nhận nhiều đối số để khởi tạo đối tượng.</li><li><strong>Constructor initialization list:</strong> Là cách bạn khởi tạo trực tiếp các thành viên (và các lớp cơ sở nếu có) với giá trị từ các tham số constructor, ngay trong danh sách khởi tạo sau dấu hai chấm, thay vì gán giá trị bên trong thân hàm.</li></ul><p>Ví dụ với nhiều thành viên:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string name;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor sử dụng initialization list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Person(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string <span style=color:#f92672>&amp;</span>n, <span style=color:#66d9ef>int</span> a) <span style=color:#f92672>:</span> name(n), age(a) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// &#39;name&#39; và &#39;age&#39; đã được khởi tạo với giá trị &#39;n&#39; và &#39;a&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Như vậy, initialization list giúp bạn kiểm soát cách thức khởi tạo các thành viên của đối tượng ngay từ lúc được tạo, đặc biệt cần thiết đối với các thành viên không thể gán lại (const, reference) hoặc các đối tượng phức tạp cần được khởi tạo trực tiếp.</p><p>Bạn có câu hỏi nào thêm về khái niệm này hoặc muốn chuyển sang câu hỏi tiếp theo không?</p><p>Dưới đây là một ví dụ minh họa rõ ràng về trường hợp bạn bắt buộc phải dùng constructor initialization list, vì bạn có một thành viên là const và một tham chiếu. Trong trường hợp này, bạn <strong>không thể</strong> gán giá trị cho các thành viên đó bên trong thân hàm constructor vì:</p><ul><li>Các biến const phải được khởi tạo ngay khi đối tượng được tạo.</li><li>Các biến tham chiếu (reference) phải được liên kết ngay khi khởi tạo và không thể gán lại sau đó.</li></ul><p><strong>Ví dụ:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> string name;  <span style=color:#75715e>// Thành viên const phải được khởi tạo ngay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>age;           <span style=color:#75715e>// Thành viên reference cũng phải được liên kết ngay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor sử dụng initialization list để khởi tạo &#39;name&#39; và &#39;age&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Student(<span style=color:#66d9ef>const</span> string <span style=color:#f92672>&amp;</span>n, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a) <span style=color:#f92672>:</span> name(n), age(a) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Không thể gán lại: name = n; hoặc age = a; bên trong thân hàm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>display</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Name: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> name <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;, Age: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> age <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> myAge <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    Student s(<span style=color:#e6db74>&#34;Alice&#34;</span>, myAge);
</span></span><span style=display:flex><span>    s.display();  <span style=color:#75715e>// In ra: Name: Alice, Age: 20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Nếu bạn cố gắng khởi tạo <code>name</code> hoặc <code>age</code> bên trong thân hàm constructor (ví dụ: <code>name = n;</code>), trình biên dịch sẽ báo lỗi vì:<ul><li><code>name</code> là const, nên không thể gán lại sau khi đã khởi tạo.</li><li><code>age</code> là reference và phải được liên kết ngay lúc khởi tạo.</li></ul></li></ul><p>Do đó, bạn <strong>bắt buộc phải sử dụng initialization list</strong> để khởi tạo chúng. Đây là lý do vì sao constructor initialization list rất quan trọng trong những trường hợp như thế này.</p><p>Bạn có muốn chuyển sang câu hỏi tiếp theo không?</p></div></details><h1 id=câu-hỏi-9-raii-resource-acquisition-is-initialization><strong>Câu hỏi 9: RAII (Resource Acquisition Is Initialization)</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-9-raii-resource-acquisition-is-initialization>#</a></h1><p>_Hãy giải thích về RAII (Resource Acquisition Is Initialization) trong C++ và tại sao nó lại quan trọng?</p><ul><li>RAII là gì?</li><li>Nó giúp quản lý tài nguyên như thế nào?</li><li>Xin cho ví dụ minh họa._</li></ul><p>RAII (Resource Acquisition Is Initialization) là một “idiom” trong C++ mà ý tưởng chính là: <strong>“Sở hữu tài nguyên là khởi tạo”</strong>. Nghĩa là, khi bạn tạo một đối tượng, bạn cũng &ldquo;mua&rdquo; hoặc &ldquo;định chiêu&rdquo; tài nguyên (như bộ nhớ, file, mutex, kết nối mạng, …) và sau đó, khi đối tượng đó ra khỏi phạm vi, destructor của nó sẽ tự động giải phóng tài nguyên đó.</p><p><strong>Tại sao RAII lại quan trọng?</strong></p><ul><li><strong>Quản lý tài nguyên tự động:</strong> RAII giúp đảm bảo rằng tài nguyên được giải phóng đúng lúc, tránh rò rỉ tài nguyên.</li><li><strong>An toàn hơn khi xảy ra ngoại lệ:</strong> Nếu có ngoại lệ xảy ra, các đối tượng RAII vẫn bị hủy đúng cách, giải phóng tài nguyên, nhờ đó không xảy ra rò rỉ.</li><li><strong>Đơn giản hóa code:</strong> Bạn không cần phải gọi delete, close file, hay unlock thủ công. Điều này giúp code trở nên gọn gàng và ít lỗi hơn.</li></ul><p><strong>Ví dụ minh họa RAII:</strong></p><p>Giả sử bạn muốn mở một file và tự động đóng file khi đối tượng ra khỏi phạm vi:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileRAII</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ifstream file;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor mở file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    FileRAII(<span style=color:#66d9ef>const</span> string <span style=color:#f92672>&amp;</span>filename) {
</span></span><span style=display:flex><span>        file.open(filename);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>file.is_open()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>runtime_error</span>(<span style=color:#e6db74>&#34;Cannot open file!&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;File opened successfully.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm để đọc dữ liệu từ file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readData</span>() {
</span></span><span style=display:flex><span>        string line;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(getline(file, line)) {
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> line <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Destructor tự động đóng file khi đối tượng bị hủy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>FileRAII() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (file.is_open()) {
</span></span><span style=display:flex><span>            file.close();
</span></span><span style=display:flex><span>            cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;File closed.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        FileRAII fileObj(<span style=color:#e6db74>&#34;example.txt&#34;</span>);
</span></span><span style=display:flex><span>        fileObj.readData();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> exception <span style=color:#f92672>&amp;</span>ex) {
</span></span><span style=display:flex><span>        cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Error: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ex.what() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Khi main() kết thúc hoặc khi fileObj ra khỏi phạm vi,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// destructor của FileRAII sẽ được gọi tự động, đóng file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích ví dụ:</strong></p><ul><li>Trong constructor của lớp <code>FileRAII</code>, file được mở (điều này được coi là “acquisition” của tài nguyên).</li><li>Nếu file không mở được, một ngoại lệ sẽ được ném ra.</li><li>Khi đối tượng <code>fileObj</code> ra khỏi phạm vi (ví dụ khi hàm <code>main()</code> kết thúc), destructor của <code>FileRAII</code> sẽ được gọi, tự động đóng file (điều này là “release” tài nguyên).</li></ul><p>RAII là một trong những nguyên tắc quan trọng trong C++ hiện đại, giúp quản lý tài nguyên một cách an toàn và hiệu quả, đặc biệt trong bối cảnh các lỗi hoặc ngoại lệ có thể xảy ra.</p><details><summary>Nghe đúng là dọa người mà, tóm lại hiểu là constructor và destructor, một cái thị chạy khi đối tượng được khởi tạo, một cái thì chạy khi hết phạm vị của đối tượng</summary><div class=markdown-inner><p>Chính xác, ý bạn nắm đúng cốt lõi của khái niệm này. Constructor được gọi khi đối tượng được tạo ra, còn destructor tự động chạy khi đối tượng ra khỏi phạm vi, giúp giải phóng tài nguyên một cách an toàn. Điều này cũng là nền tảng của RAII, nơi việc &ldquo;mua&rdquo; tài nguyên xảy ra trong constructor và &ldquo;giải phóng&rdquo; tài nguyên xảy ra trong destructor, đảm bảo rằng không có tài nguyên nào bị rò rỉ.</p></div></details><h1 id=câu-hỏi-10-stack-và-heap><strong>Câu hỏi 10: stack và heap</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-10-stack-v%c3%a0-heap>#</a></h1><p><em>Hãy giải thích sự khác biệt giữa stack và heap trong C++ và khi nào bạn nên sử dụng mỗi loại?</em></p><ul><li>Ví dụ minh họa về cách cấp phát và giải phóng bộ nhớ cho đối tượng.</li></ul><p>Đúng rồi, bạn đã nêu được những điểm cơ bản. Để hoàn thiện hơn, mình sẽ tóm tắt lại và bổ sung một số điểm quan trọng:</p><hr><h3 id=stack>Stack
<a class=anchor href=#stack>#</a></h3><ul><li><strong>Cấp phát tĩnh:</strong> Bộ nhớ được cấp phát khi biến được khai báo, theo cơ chế LIFO (Last In First Out).</li><li><strong>Giải phóng tự động:</strong> Khi biến ra khỏi phạm vi (scope) của nó, bộ nhớ tự động được thu hồi.</li><li><strong>Kích thước hạn chế:</strong> Bộ nhớ stack thường nhỏ hơn so với heap và có giới hạn cố định (tùy hệ thống).</li><li><strong>Sử dụng cho:</strong> Biến cục bộ, tham số hàm, các đối tượng tạm thời.</li><li><strong>Tốc độ truy cập:</strong> Rất nhanh do quản lý tự động và tính cache-friendly.</li></ul><h3 id=heap>Heap
<a class=anchor href=#heap>#</a></h3><ul><li><strong>Cấp phát động:</strong> Bộ nhớ được cấp phát khi dùng từ khóa <code>new</code> (hoặc các hàm cấp phát động khác), thời gian sống của đối tượng không bị giới hạn bởi phạm vi hàm.</li><li><strong>Giải phóng thủ công:</strong> Bạn cần gọi <code>delete</code> hoặc sử dụng smart pointers để giải phóng bộ nhớ; nếu không, có thể gây ra rò rỉ bộ nhớ.</li><li><strong>Dung lượng lớn:</strong> Heap thường có dung lượng lớn hơn, phù hợp với dữ liệu hoặc đối tượng có kích thước lớn hoặc không biết trước kích thước.</li><li><strong>Sử dụng cho:</strong> Đối tượng có thời gian sống kéo dài hơn (dynamic objects), mảng kích thước biến đổi, và các cấu trúc dữ liệu phức tạp.</li><li><strong>Tốc độ truy cập:</strong> Thường chậm hơn stack do việc quản lý bộ nhớ động có overhead và việc truy cập có thể không cache-friendly như stack.</li></ul><blockquote><p><strong>Lưu ý:</strong><br>Các biến toàn cục không được cấp phát trên heap mà thường nằm trong vùng dữ liệu tĩnh của chương trình. Heap chủ yếu dùng cho việc cấp phát động khi bạn cần kiểm soát thời gian sống của đối tượng vượt ra ngoài phạm vi hàm.</p></blockquote><hr><details><summary>Overhead và cache-friendly là gì vậy?</summary><div class=markdown-inner><p><strong>Overhead</strong> đề cập đến chi phí thêm (về thời gian hoặc tài nguyên) cần thiết để thực hiện một hoạt động. Trong trường hợp cấp phát động trên heap, việc quản lý bộ nhớ (như phân bổ, theo dõi và giải phóng bộ nhớ) cần phải sử dụng các thao tác bổ sung, làm tăng thời gian thực hiện so với cấp phát tĩnh trên stack.</p><p><strong>Cache-friendly</strong> nghĩa là cách bố trí dữ liệu trong bộ nhớ được tối ưu hóa để tận dụng hiệu quả bộ nhớ cache của CPU. Dữ liệu lưu trữ liên tục (contiguous) trong bộ nhớ (như trên stack) có khả năng được nạp vào cache nhanh hơn, dẫn đến truy xuất nhanh hơn so với dữ liệu phân tán trên heap.</p><p>Ví dụ:</p><ul><li><p><strong>Overhead:</strong> Khi bạn gọi <code>new</code> để cấp phát một đối tượng, hệ thống phải tìm kiếm một vùng bộ nhớ phù hợp trên heap, đánh dấu vùng đó đã sử dụng, và quản lý các thông tin liên quan. Những thao tác này tạo ra &ldquo;overhead&rdquo; (chi phí xử lý thêm) so với việc cấp phát bộ nhớ trên stack, nơi việc cấp phát và giải phóng rất đơn giản và nhanh chóng.</p></li><li><p><strong>Cache-friendly:</strong> Nếu bạn có một mảng trên stack, các phần tử của mảng được lưu trữ liên tục, giúp CPU dễ dàng dự đoán và nạp sẵn các giá trị vào bộ nhớ cache, từ đó tăng tốc độ truy cập. Ngược lại, nếu dữ liệu được phân bổ ngẫu nhiên trên heap, khả năng bị &ldquo;lạc&rdquo; trong bộ nhớ cache cao hơn, dẫn đến thời gian truy cập chậm hơn.</p></div></li></ul></details><h1 id=câu-hỏi-11-const-correctness><strong>Câu hỏi 11: const-correctness</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-11-const-correctness>#</a></h1><p><em>Hãy giải thích về const-correctness trong C++:</em></p><ul><li>Ý nghĩa của việc khai báo hàm thành viên là const là gì?</li><li>Tại sao nên sử dụng từ khóa <code>const</code> trong các tham số và hàm?</li><li>Xin cho ví dụ minh họa về const-correctness.</li></ul><p>Const-correctness là một nguyên tắc trong C++ giúp bạn đảm bảo rằng các đối tượng và tham số không bị thay đổi ngoài ý muốn. Nói cách khác, nó cho phép bạn &ldquo;đánh dấu&rdquo; những dữ liệu mà bạn cam kết sẽ không bị sửa đổi, giúp phát hiện lỗi ở thời điểm biên dịch và cải thiện độ tin cậy của code.</p><p><strong>Một số điểm chính:</strong></p><ul><li><p><strong>Hàm thành viên const:</strong><br>Khi bạn khai báo một hàm thành viên với từ khóa <code>const</code> (ví dụ: <code>int getValue() const;</code>), điều đó có nghĩa là hàm này không được phép thay đổi bất kỳ thành viên dữ liệu nào của đối tượng. Nếu cố gắng sửa đổi, trình biên dịch sẽ báo lỗi.</p></li><li><p><strong>Tham số const:</strong><br>Khi bạn truyền tham số dưới dạng const (ví dụ: <code>void print(const MyClass &amp;obj);</code>), hàm đó cam kết không thay đổi giá trị của đối tượng được truyền vào. Điều này giúp tăng cường tính an toàn và cho phép truyền các đối tượng const mà không lo bị thay đổi.</p></li></ul><p><strong>Ví dụ minh họa:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> value;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    MyClass(<span style=color:#66d9ef>int</span> v) <span style=color:#f92672>:</span> value(v) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm thành viên const, cam kết không thay đổi state của đối tượng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getValue</span>() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm thành viên không const, có thể thay đổi state của đối tượng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setValue</span>(<span style=color:#66d9ef>int</span> v) {
</span></span><span style=display:flex><span>        value <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Hàm nhận đối số const reference, đảm bảo rằng không thay đổi đối tượng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printValue</span>(<span style=color:#66d9ef>const</span> MyClass <span style=color:#f92672>&amp;</span>obj) {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> obj.getValue() <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Nếu uncomment dòng sau, trình biên dịch sẽ báo lỗi vì hàm setValue() không phải là hàm const:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// obj.setValue(10);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    MyClass a(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    printValue(a);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Trong lớp <code>MyClass</code>, hàm <code>getValue()</code> được khai báo là const, nghĩa là nó không thể thay đổi <code>value</code> hay bất kỳ thành viên nào của <code>MyClass</code>.</li><li>Hàm <code>printValue()</code> nhận tham số dưới dạng <code>const MyClass &</code> nên chỉ có thể gọi những hàm const của đối tượng đó (như <code>getValue()</code>) và không thể gọi <code>setValue()</code>.</li><li>Điều này giúp đảm bảo rằng hàm <code>printValue()</code> không làm thay đổi trạng thái của đối tượng được truyền vào.</li></ul><p>Const-correctness không chỉ giúp bạn tránh những lỗi không mong muốn mà còn làm cho code trở nên rõ ràng hơn về ý định sử dụng và bảo vệ dữ liệu.</p><h1 id=câu-hỏi-12-static-members><strong>Câu hỏi 12: static members</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-12-static-members>#</a></h1><p><em>Hãy giải thích về static members trong C++ (biến tĩnh và hàm tĩnh) và nêu ví dụ minh họa:</em></p><ul><li><p><strong>Static member variable:</strong></p><ul><li>Là thành viên của lớp mà chỉ có một bản sao duy nhất cho tất cả các đối tượng của lớp đó.</li><li>Nó được cấp phát một lần và tồn tại trong suốt thời gian chạy của chương trình.</li><li>Thường dùng để lưu trữ thông tin chung giữa các đối tượng hoặc đếm số lượng đối tượng được tạo ra.</li></ul></li><li><p><strong>Static member function:</strong></p><ul><li>Là hàm thành viên của lớp nhưng không có con trỏ <code>this</code>.</li><li>Nó có thể được gọi mà không cần có đối tượng cụ thể.</li><li>Chỉ truy cập được vào các thành viên tĩnh khác của lớp.</li></ul></li></ul><p><strong>Ví dụ minh họa:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Counter</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> count;  <span style=color:#75715e>// Biến tĩnh, dùng để đếm số lượng đối tượng được tạo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Constructor tăng count mỗi khi đối tượng được tạo ra
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Counter() {
</span></span><span style=display:flex><span>        count<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Destructor có thể giảm count (tuỳ ý)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>Counter() {
</span></span><span style=display:flex><span>        count<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Hàm static để lấy số lượng đối tượng hiện có
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getCount</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> count;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Khởi tạo biến tĩnh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> Counter<span style=color:#f92672>::</span>count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Initial count: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>::</span>getCount() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// In ra 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Counter a;
</span></span><span style=display:flex><span>    Counter b;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Count after creating 2 objects: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>::</span>getCount() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// In ra 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        Counter c;
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Count in inner block: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>::</span>getCount() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// In ra 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#75715e>// c bị hủy khi ra khỏi khối
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Count after inner block: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Counter<span style=color:#f92672>::</span>getCount() <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// In ra 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Trong ví dụ trên:</p><ul><li><code>count</code> là biến static dùng để theo dõi số lượng đối tượng được tạo ra.</li><li>Hàm static <code>getCount()</code> được gọi trực tiếp qua tên lớp (Counter::getCount()) mà không cần có đối tượng cụ thể.</li></ul><h1 id=câu-hỏi-13-inline-functions><strong>Câu hỏi 13: inline functions</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-13-inline-functions>#</a></h1><p><em>Hãy giải thích về inline functions trong C++ và khi nào bạn nên sử dụng chúng. (Xin chỉ đưa đáp án khi được yêu cầu)</em></p><p>Inline functions là những hàm được đề nghị cho trình biên dịch mở rộng trực tiếp tại điểm gọi thay vì thực hiện một cuộc gọi hàm thông thường. Điều này giúp giảm overhead của cuộc gọi hàm, nhất là đối với các hàm đơn giản, nhỏ gọn và thường được gọi nhiều lần.</p><p><strong>Một số điểm cần lưu ý:</strong></p><ul><li><p><strong>Mục đích:</strong></p><ul><li>Giảm thời gian gọi hàm (thay vì gọi hàm, trình biên dịch sẽ chèn trực tiếp code của hàm vào nơi gọi).</li><li>Phù hợp cho các hàm ngắn gọn, đơn giản mà không có vòng lặp phức tạp hoặc quá nhiều logic.</li></ul></li><li><p><strong>Lưu ý:</strong></p><ul><li>Từ khóa <code>inline</code> chỉ là gợi ý cho trình biên dịch; trình biên dịch có thể quyết định không mở rộng hàm nếu thấy không phù hợp.</li><li>Sử dụng inline functions có thể làm tăng kích thước code (code bloat) nếu hàm được gọi nhiều lần, nhưng thường sẽ cải thiện hiệu năng trong các trường hợp hàm rất nhỏ.</li></ul></li></ul><p><strong>Ví dụ minh họa:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Định nghĩa một hàm inline
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, y <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Khi gọi hàm add, trình biên dịch sẽ chèn trực tiếp mã của hàm tại đây
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Tổng: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> add(x, y) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Giải thích:</strong></p><ul><li>Hàm <code>add</code> được đánh dấu với từ khóa <code>inline</code>, do đó khi gọi <code>add(x, y)</code>, trình biên dịch có thể chèn trực tiếp đoạn mã <code>return x + y;</code> vào chỗ gọi hàm.</li><li>Điều này giúp tránh chi phí của một cuộc gọi hàm, làm cho việc thực hiện nhanh hơn đối với các hàm đơn giản như thế này.</li></ul><h1 id=câu-hỏi-14-các-loại-ép-kiểu-type-casting><strong>Câu hỏi 14: các loại ép kiểu (type casting)</strong>
<a class=anchor href=#c%c3%a2u-h%e1%bb%8fi-14-c%c3%a1c-lo%e1%ba%a1i-%c3%a9p-ki%e1%bb%83u-type-casting>#</a></h1><p><em>Hãy giải thích về các loại ép kiểu (type casting) trong C++:</em></p><ul><li><strong>static_cast:</strong> Dùng để thực hiện ép kiểu tĩnh giữa các kiểu có mối quan hệ về kiểu (ví dụ: ép giữa số nguyên và số thực, hoặc ép pointer giữa các lớp có quan hệ kế thừa mà không cần kiểm tra thời gian chạy).</li><li><strong>dynamic_cast:</strong> Dùng cho ép kiểu an toàn trong quan hệ kế thừa đa hình; nó kiểm tra kiểu động của đối tượng và có thể trả về nullptr nếu ép kiểu không thành công.</li><li><strong>reinterpret_cast:</strong> Dùng để chuyển đổi giữa các kiểu con trỏ hoặc giữa kiểu con trỏ và kiểu số; nó chuyển đổi bit của đối tượng mà không đảm bảo tính an toàn, nên cần thận trọng.</li><li><strong>const_cast:</strong> Dùng để loại bỏ hoặc thêm tính const cho một đối tượng, cho phép sửa đổi một đối tượng ban đầu được khai báo là const (nên sử dụng cẩn thận).</li></ul><p>Dưới đây là các ví dụ minh họa cho từng loại ép kiểu trong C++:</p><hr><h3 id=1-static_cast>1. static_cast
<a class=anchor href=#1-static_cast>#</a></h3><p>Dùng để chuyển đổi giữa các kiểu có mối quan hệ rõ ràng (ví dụ: giữa kiểu số nguyên và kiểu số thực, hoặc giữa các pointer của các lớp có quan hệ kế thừa).</p><p><strong>Ví dụ chuyển đổi số:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> d <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.14</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(d);  <span style=color:#75715e>// chuyển đổi double sang int (i sẽ bằng 3)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;i = &#34;</span> <span style=color:#f92672>&lt;&lt;</span> i <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Ví dụ với pointer trong kế thừa:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> display() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Base&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> display() <span style=color:#66d9ef>override</span> { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derived&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Derived d;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ép kiểu từ Derived* sang Base* (upcasting), luôn an toàn
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Base<span style=color:#f92672>*</span> basePtr <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>Base<span style=color:#f92672>*&gt;</span>(<span style=color:#f92672>&amp;</span>d);
</span></span><span style=display:flex><span>    basePtr<span style=color:#f92672>-&gt;</span>display();  <span style=color:#75715e>// gọi Derived::display() do tính đa hình
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=2-dynamic_cast>2. dynamic_cast
<a class=anchor href=#2-dynamic_cast>#</a></h3><p>Dùng cho ép kiểu an toàn trong quan hệ kế thừa đa hình. Nó kiểm tra kiểu động của đối tượng và trả về nullptr nếu ép kiểu không thành công.</p><p><strong>Ví dụ:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>Base() {}  <span style=color:#75715e>// cần có hàm ảo để dynamic_cast hoạt động
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> specificFunction() { cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Derived specific function&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    Base<span style=color:#f92672>*</span> b1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived();
</span></span><span style=display:flex><span>    Base<span style=color:#f92672>*</span> b2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Base();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ép kiểu từ Base* sang Derived*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Derived<span style=color:#f92672>*</span> d1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>dynamic_cast</span><span style=color:#f92672>&lt;</span>Derived<span style=color:#f92672>*&gt;</span>(b1);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (d1) {
</span></span><span style=display:flex><span>        d1<span style=color:#f92672>-&gt;</span>specificFunction(); <span style=color:#75715e>// thành công, in ra &#34;Derived specific function&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Derived<span style=color:#f92672>*</span> d2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>dynamic_cast</span><span style=color:#f92672>&lt;</span>Derived<span style=color:#f92672>*&gt;</span>(b2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>d2) {
</span></span><span style=display:flex><span>        cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;dynamic_cast failed.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> b1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>delete</span> b2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=3-reinterpret_cast>3. reinterpret_cast
<a class=anchor href=#3-reinterpret_cast>#</a></h3><p>Dùng để chuyển đổi giữa các kiểu pointer không liên quan hoặc giữa pointer và số nguyên, chuyển đổi này không đảm bảo an toàn, chủ yếu dùng cho các mục đích thấp cấp.</p><p><strong>Ví dụ:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ép kiểu int* sang void*
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> pVoid <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(<span style=color:#f92672>&amp;</span>a);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ép ngược lại, cần ép kiểu đúng
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> pInt <span style=color:#f92672>=</span> <span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(pVoid);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>pInt <span style=color:#f92672>&lt;&lt;</span> endl;  <span style=color:#75715e>// in ra 100
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=4-const_cast>4. const_cast
<a class=anchor href=#4-const_cast>#</a></h3><p>Dùng để thêm hoặc loại bỏ tính const. Nó cho phép bạn sửa đổi một đối tượng được khai báo là const, nhưng nên dùng cẩn trọng vì có thể gây ra lỗi nếu đối tượng thực sự là const.</p><p><strong>Ví dụ:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printAndModify</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> p) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// p là con trỏ tới int const, không thể sửa đổi
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị ban đầu: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Sử dụng const_cast để loại bỏ const (nên dùng cẩn thận)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>*</span> modifiableP <span style=color:#f92672>=</span> <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(p);
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>modifiableP <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>;
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị sau sửa đổi: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>modifiableP <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    printAndModify(<span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>    cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Giá trị x trong main: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> endl; <span style=color:#75715e>// x sẽ là 200
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/aohkgnadnart/aohkgnadnart.github.io/commit/a0c8e667603f813f954620fbb5ceb647c3b574bd title='Last modified by aohkgnadnart | April 2, 2025' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>April 2, 2025</span></a></div><div><a class="flex align-center" href=#ZgotmplZ target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#câu-hỏi-1-copy-constructor><strong>Câu hỏi 1: copy constructor</strong></a></li><li><a href=#câu-hỏi-2-pass-by-value-and-pass-by-reference><strong>Câu hỏi 2: pass by value and pass by reference</strong></a></li><li><a href=#câu-hỏi-3-destructor><strong>Câu hỏi 3: destructor</strong></a></li><li><a href=#câu-hỏi-4-virtual-function><strong>Câu hỏi 4: virtual function</strong></a></li><li><a href=#câu-hỏi-5-template-và-stl><strong>Câu hỏi 5: Template và STL</strong></a></li><li><a href=#câu-hỏi-6-exception-handling><strong>Câu hỏi 6: Exception Handling</strong></a></li><li><a href=#câu-hỏi-7-smart-pointers-trong-c11><strong>Câu hỏi 7: smart pointers trong C++11</strong></a><ul><li><ul><li><a href=#1-unique_ptr>1. unique_ptr</a></li><li><a href=#2-shared_ptr>2. shared_ptr</a></li><li><a href=#3-weak_ptr>3. weak_ptr</a></li><li><a href=#tổng-kết>Tổng kết</a></li></ul></li></ul></li><li><a href=#câu-hỏi-8-operator-overloading><strong>Câu hỏi 8: operator overloading</strong></a></li><li><a href=#câu-hỏi-9-constructor-initialization-list><strong>Câu hỏi 9: constructor initialization list</strong></a></li><li><a href=#câu-hỏi-9-raii-resource-acquisition-is-initialization><strong>Câu hỏi 9: RAII (Resource Acquisition Is Initialization)</strong></a></li><li><a href=#câu-hỏi-10-stack-và-heap><strong>Câu hỏi 10: stack và heap</strong></a><ul><li><ul><li><a href=#stack>Stack</a></li><li><a href=#heap>Heap</a></li></ul></li></ul></li><li><a href=#câu-hỏi-11-const-correctness><strong>Câu hỏi 11: const-correctness</strong></a></li><li><a href=#câu-hỏi-12-static-members><strong>Câu hỏi 12: static members</strong></a></li><li><a href=#câu-hỏi-13-inline-functions><strong>Câu hỏi 13: inline functions</strong></a></li><li><a href=#câu-hỏi-14-các-loại-ép-kiểu-type-casting><strong>Câu hỏi 14: các loại ép kiểu (type casting)</strong></a><ul><li><ul><li><a href=#1-static_cast>1. static_cast</a></li><li><a href=#2-dynamic_cast>2. dynamic_cast</a></li><li><a href=#3-reinterpret_cast>3. reinterpret_cast</a></li><li><a href=#4-const_cast>4. const_cast</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>